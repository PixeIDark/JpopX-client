--- src/api/auth.ts ---
import { axiosInstance } from "@/lib/axios/instance";
import {
  AccountRequest,
  AccountResponse,
  LoginRequest,
  LoginResponse,
  RefreshRequest,
} from "@/types/auth.type";

const url = "auth";

export const authApi = {
  account: (data: AccountRequest) => axiosInstance.post<AccountResponse>(`${url}/signup`, data),
  login: (data: LoginRequest) => axiosInstance.post<LoginResponse>(`${url}/login`, data),
  logout: async (accessToken: string) => {
    try {
      await fetch(`${process.env.NEXT_PUBLIC_API_URL}/auth/logout`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${accessToken}`,
        },
      });
    } catch (error) {
      console.error("Server Logout Failed:", error);
    }
  },
  refresh: async (refreshToken: RefreshRequest) => {
    const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/${url}/refresh`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      body: JSON.stringify({ refreshToken }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    return response.json();
  },
};


--- src/api/search.ts ---
import { axiosInstance } from "@/lib/axios/instance";
import { SearchRequest, SearchResponse } from "@/types/search.type";

const url = "search";

export const searchApi = (params: SearchRequest) =>
  axiosInstance.get<SearchResponse>(url, {
    params: {
      text: params.text || "",
      searchType: params.searchType || "both",
      sort: params.sort || "popular",
      limit: params.limit || 20,
      page: params.page || 1,
    },
  });


--- src/api/users.ts ---
import { axiosInstance } from "@/lib/axios/instance";

const url = "users";

export const usersApi = {
  all: () => axiosInstance.get<AllResponse>(`${url}`),
  me: () => axiosInstance.get<MeResponse>(`${url}/me`),
};


--- src/app/(auth)/account/_components/AccountForm/AccountForm.tsx ---
"use client";

import { useForm } from "react-hook-form";
import { accountSchema, AccountSchema } from "@/lib/zod/auth";
import { zodResolver } from "@hookform/resolvers/zod";
import TextField from "@/components/common/Field/TextField";
import PasswordField from "@/components/common/Field/PasswordField";
import Button from "@/components/ui/Button";
import { useAccountMutation } from "@/query/auth/mutations/useAccountMutation";

function AccountForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<AccountSchema>({
    resolver: zodResolver(accountSchema),
  });
  const { mutate: accountMutate } = useAccountMutation();

  const onSubmit = (data: AccountSchema) => accountMutate(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="mt-3 flex flex-col gap-6">
      <TextField
        id="name"
        name="name"
        type="text"
        error={errors.name}
        placeholder="Your name"
        register={register}
      />
      <TextField
        id="email"
        name="email"
        type="email"
        error={errors.email}
        placeholder="Email Address"
        register={register}
      />
      <PasswordField
        id="password"
        name="password"
        error={errors.password}
        placeholder="Password"
        register={register}
      />
      <PasswordField
        id="passwordConfirm"
        name="passwordConfirm"
        error={errors.passwordConfirm}
        placeholder="Confirm Password"
        register={register}
      />
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Loading" : "Account"}
      </Button>
    </form>
  );
}

export default AccountForm;


--- src/app/(auth)/account/_components/AccountForm/index.ts ---
export { default } from "./AccountForm";


--- src/app/(auth)/account/page.tsx ---
import AccountForm from "@/app/(auth)/account/_components/AccountForm";

function AccountPage() {
  return (
    <div>
      <AccountForm />
    </div>
  );
}

export default AccountPage;


--- src/app/(auth)/login/_components/LoginForm/LoginForm.tsx ---
"use client";

import { useForm } from "react-hook-form";
import { loginSchema, LoginSchema } from "@/lib/zod/auth";
import { zodResolver } from "@hookform/resolvers/zod";
import TextField from "@/components/common/Field/TextField";
import PasswordField from "@/components/common/Field/PasswordField";
import Button from "@/components/ui/Button";
import Link from "next/link";
import { useLoginMutation } from "@/query/auth/mutations/useLoginMutation";

function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginSchema>({
    resolver: zodResolver(loginSchema),
  });
  const { mutate: loginMutate } = useLoginMutation();

  const onSubmit = (data: LoginSchema) =>
    loginMutate({
      email: data.email,
      password: data.password,
    });

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="mt-3 flex flex-col gap-6">
      <TextField
        id="email"
        name="email"
        type="email"
        error={errors.email}
        placeholder="Email Address"
        register={register}
      />
      <PasswordField
        id="password"
        name="password"
        error={errors.password}
        placeholder="Password"
        register={register}
      />
      <p className="-mt-2 text-text-p">Forgot password?</p>
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Loading" : "Log in"}
      </Button>
      <Button type="submit" variant="link" asChild>
        <Link href="/account">New User Sign Up</Link>
      </Button>
    </form>
  );
}

export default LoginForm;


--- src/app/(auth)/login/_components/LoginForm/index.ts ---
export { default } from "./LoginForm";


--- src/app/(auth)/login/page.tsx ---
import LoginForm from "@/app/(auth)/login/_components/LoginForm";

export default async function LoginPage() {
  return (
    <div>
      <LoginForm />
    </div>
  );
}


--- src/app/_components/layout/BottomNav/BottomNavItem/BottomNavItem.tsx ---
"use client";

import React from "react";
import { usePathname } from "next/navigation";
import Link from "next/link";

interface BottomNavItemProps {
  path: string;
  label: string;
  Icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;
  IconFill: React.ComponentType<React.SVGProps<SVGSVGElement>>;
}

function BottomNavItem({ path, label, Icon, IconFill }: BottomNavItemProps) {
  const pathname = usePathname();

  const isActive = path === pathname;
  return (
    <Link href={path} className="flex w-16 flex-col items-center justify-center gap-1">
      {isActive ? (
        <IconFill width={24} height={24} className="fill-icon-bg" />
      ) : (
        <Icon width={24} height={24} className="fill-icon-stroke" />
      )}
      <p className="text-xs text-text-p">{label}</p>
    </Link>
  );
}

export default BottomNavItem;


--- src/app/_components/layout/BottomNav/BottomNavItem/index.ts ---
export { default } from "./BottomNavItem";


--- src/app/_components/layout/BottomNav/BottomNav.tsx ---
"use client";

import Home from "@/assets/icons/home/home.svg";
import HomeFill from "@/assets/icons/home/home_fill.svg";
import Search from "@/assets/icons/search/search.svg";
import SearchFill from "@/assets/icons/search/search_fill.svg";
import BottomNavItem from "@/app/_components/layout/BottomNav/BottomNavItem";
import { useSelectedLayoutSegment } from "next/navigation";

function BottomNav() {
  const segment = useSelectedLayoutSegment();
  if (segment === "(auth)") return null;

  const navItems = [
    {
      path: "/",
      label: "home",
      Icon: Home,
      IconFill: HomeFill,
    },
    {
      path: "/search",
      label: "search",
      Icon: Search,
      IconFill: SearchFill,
    },
  ];

  return (
    <div>
      <div className="pt fixed bottom-0 flex w-full items-center justify-between border-t border-solid-default bg-body-default px-4 pb-3 pt-5">
        {navItems.map((item) => (
          <BottomNavItem
            key={item.path}
            path={item.path}
            label={item.label}
            Icon={item.Icon}
            IconFill={item.IconFill}
          />
        ))}
      </div>
      <div className="h-[77px] w-full" />
    </div>
  );
}

export default BottomNav;


--- src/app/_components/layout/BottomNav/index.ts ---
export { default } from "./BottomNav";


--- src/app/_components/layout/TopNav/TopNav.tsx ---
"use client";

import { ArrowLeft } from "lucide-react";
import { usePathname, useRouter } from "next/navigation";
import Link from "next/link";
import ThemeToggle from "@/components/common/ThemeToggle";

const NAV_TITLE = {
  "/": "Home",
  "/login": "Login",
  "/account": "Account",
  "/search": "Search",
} as const;

type NavPath = keyof typeof NAV_TITLE;

function TopNav() {
  const pathname = usePathname();
  const router = useRouter();

  const title = pathname in NAV_TITLE ? NAV_TITLE[pathname as NavPath] : "Unknown Page";

  return (
    <div className="pt sticky top-0 flex items-center justify-between border-b border-solid-default bg-body-default px-4 pb-3 pt-5">
      <button onClick={() => router.back()} className="p-2">
        <ArrowLeft size={24} strokeWidth={1.5} />
      </button>
      <Link href="/">
        <h1 className="text-lg font-semibold text-text-h">{title}</h1>
      </Link>
      <ThemeToggle />
    </div>
  );
}

export default TopNav;


--- src/app/_components/layout/TopNav/index.ts ---
export { default } from "./TopNav";


--- src/app/_components/test/FuckAccessToken.tsx ---
import Button from "@/components/ui/Button";
import { getSession, signIn } from "next-auth/react";

function FuckAccessToken() {
  const a = async () => {
    const session = await getSession();
    console.log(session);
    const result = await signIn("Refresh", {
      refreshToken: session?.user.refreshToken,
      accessToken: "f",
      redirect: false,
    });
  };

  return <Button onClick={a}>Fuck AccessToken!</Button>;
}

export default FuckAccessToken;


--- src/app/_components/test/GetMe.tsx ---
import Button from "@/components/ui/Button";
import { usersApi } from "@/api/users";

function GetMe() {
  const a = async () => {
    const b = await usersApi.me();
    console.log(b);
  };

  return <Button onClick={a}>Get me</Button>;
}

export default GetMe;


--- src/app/_components/test/LogoutMe.tsx ---
import Button from "@/components/ui/Button";
import { getSession, signOut } from "next-auth/react";

function LogoutMe() {
  const a = async () => {
    let session = await getSession();
    console.log(session);
    await signOut({ redirect: false });
    session = await getSession();
    console.log(session);
  };

  return <Button onClick={a}>log out</Button>;
}

export default LogoutMe;


--- src/app/_providers/QueryProvider.tsx ---
"use client";

import { isServer, QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import * as React from "react";
import { ReactQueryStreamedHydration } from "@tanstack/react-query-next-experimental";

const makeQueryClient = () => {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1000,
        gcTime: 10 * 60 * 1000,
      },
    },
  });
};

let browserQueryClient: QueryClient | undefined = undefined;

const getQueryClient = () => {
  if (isServer) {
    return makeQueryClient();
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
};

function QueryProvider({ children }: { children: React.ReactNode }) {
  const queryClient = getQueryClient();

  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryStreamedHydration>{children}</ReactQueryStreamedHydration>
      <ReactQueryDevtools initialIsOpen={false} buttonPosition="bottom-left" />
    </QueryClientProvider>
  );
}

export default QueryProvider;


--- src/app/_providers/SessionProvider.tsx ---
"use client";

import React from "react";
import { SessionProvider as Provider } from "next-auth/react";

interface SessionProviderProps {
  children: React.ReactNode;
  session: any;
}

function SessionProvider({ children, session }: SessionProviderProps) {
  return <Provider session={session}>{children}</Provider>;
}

export default SessionProvider;


--- src/app/api/auth/[...nextauth]/route.ts ---
import NextAuth from "next-auth";
import { authOptions } from "@/lib/next-auth/nextAuth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


--- src/app/search/_components/SearchPanel/SearchFilter/SearchFilter.tsx ---
import Button from "@/components/ui/Button";
import React, { useState } from "react";
import { SearchPanelParams, SearchType } from "@/types/search.type";

interface SearchFilterProps {
  handleApplyParams: (params: SearchPanelParams) => void;
  initialSearchType: SearchType;
}

const SEARCH_TYPES = ["both", "title", "artist"] as const;

function SearchFilter({ handleApplyParams, initialSearchType }: SearchFilterProps) {
  const [choiceType, setChoiceType] = useState(initialSearchType);

  const handleApplyType = (e: React.MouseEvent<HTMLButtonElement>): void => {
    const searchType = e.currentTarget.value as SearchType;
    setChoiceType(searchType);
    handleApplyParams({ searchType });
  };

  return (
    <div className="flex gap-3">
      {SEARCH_TYPES.map((type, idx) => (
        <Button
          key={idx}
          variant={choiceType === type ? "outline" : "ghost"}
          value={type}
          onClick={handleApplyType}
          className="h-11 max-w-[70px] text-sm"
        >
          {type}
        </Button>
      ))}
    </div>
  );
}

export default SearchFilter;


--- src/app/search/_components/SearchPanel/SearchFilter/index.ts ---
export { default } from "./SearchFilter";


--- src/app/search/_components/SearchPanel/SearchInput/_hooks/useQueryInput.ts ---
import { useEffect, useRef } from "react";

export function useSyncInputValue(initialValue: string) {
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (inputRef.current && initialValue) {
      inputRef.current.value = initialValue;
    }
  }, [initialValue]);

  return inputRef;
}


--- src/app/search/_components/SearchPanel/SearchInput/SearchInput.tsx ---
"use client";

import Input from "@/components/ui/Input";
import React, { FormEvent } from "react";
import { SearchPanelParams } from "@/types/search.type";
import { useSyncInputValue } from "@/app/search/_components/SearchPanel/SearchInput/_hooks/useSyncInputValue";

interface SearchInputProps {
  handleApplyParams: (params: SearchPanelParams) => void;
  initialText: string;
}

function SearchInput({ handleApplyParams, initialText }: SearchInputProps) {
  const inputRef = useSyncInputValue(initialText);

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    const text = inputRef.current?.value.trim() || "";
    handleApplyParams({ text });
  };

  return (
    <form onSubmit={handleSubmit} className="w-full">
      <Input
        placeholder="검색어를 입력하세요"
        ref={inputRef}
        type="text"
        defaultValue={initialText}
      />
    </form>
  );
}

export default SearchInput;


--- src/app/search/_components/SearchPanel/SearchInput/index.ts ---
export { default } from "./SearchInput";


--- src/app/search/_components/SearchPanel/SearchSort/SearchSort.tsx ---
"use client";

import Button from "@/components/ui/Button";
import { SearchPanelParams, Sort } from "@/types/search.type";
import React, { useState } from "react";

interface SearchSortProps {
  handleApplyParams: (params: SearchPanelParams) => void;
  initialSort: Sort;
}

const SORT_TYPES = ["popular", "latest"] as const;

function SearchSort({ handleApplyParams, initialSort }: SearchSortProps) {
  const [choiceSort, setChoiceSort] = useState(initialSort);

  const handleApplySort = (e: React.MouseEvent<HTMLButtonElement>) => {
    const sort = e.currentTarget.value as Sort;
    setChoiceSort(sort);
    handleApplyParams({ sort });
  };

  return (
    <div className="flex rounded-xl bg-button-ghost p-1">
      {SORT_TYPES.map((sort, idx) => (
        <Button
          key={idx}
          variant={choiceSort === sort ? "link" : "ghost"}
          value={sort}
          onClick={handleApplySort}
          className="h-8"
        >
          {sort}
        </Button>
      ))}
    </div>
  );
}

export default SearchSort;


--- src/app/search/_components/SearchPanel/SearchSort/index.ts ---


--- src/app/search/_components/SearchPanel/_hooks/useChangeUrl.ts ---
import { SearchPanelParams } from "@/types/search.type";
import { useRouter } from "next/navigation";

export function useChangeUrl(params: SearchPanelParams) {
  const router = useRouter();
  const { text, searchType, sort } = params;

  const onApplySearchParams = (params: SearchPanelParams) => {
    const searchParams = new URLSearchParams([
      ["text", params.text ?? text ?? ""],
      ["searchType", params.searchType || searchType || "both"],
      ["sort", params.sort || sort || "popular"],
    ]);
    router.push(`/search?${searchParams}`);
  };

  return { text, searchType, sort, onApplySearchParams };
}


--- src/app/search/_components/SearchPanel/SearchPanel.tsx ---
"use client";

import SearchInput from "@/app/search/_components/SearchPanel/SearchInput";
import SearchFilter from "@/app/search/_components/SearchPanel/SearchFilter";
import { SearchPanelParams } from "@/types/search.type";
import SearchSort from "@/app/search/_components/SearchPanel/SearchSort/SearchSort";
import { useChangeUrl } from "@/app/search/_components/SearchPanel/_hooks/useChangeUrl";

interface SearchPanelProps {
  params: SearchPanelParams;
}

function SearchPanel({ params }: SearchPanelProps) {
  const { onApplySearchParams, searchType, text, sort } = useChangeUrl(params);

  return (
    <div className="mt-3 flex flex-col gap-3">
      <SearchInput handleApplyParams={onApplySearchParams} initialText={text || ""} />
      <SearchFilter
        handleApplyParams={onApplySearchParams}
        initialSearchType={searchType || "both"}
      />
      <SearchSort handleApplyParams={onApplySearchParams} initialSort={sort || "popular"} />
    </div>
  );
}

export default SearchPanel;


--- src/app/search/_components/SearchPanel/index.ts ---
export { default } from "./SearchPanel";


--- src/app/search/_components/SearchResult/SearchList/SearchList.tsx ---
import { SearchItems } from "@/types/search.type";
import SongCard from "@/components/common/SongCard";

interface SearchListProps {
  songs: SearchItems[];
}

function SearchList({ songs }: SearchListProps) {
  return (
    <li className="flex flex-col gap-6">
      {songs.map((song) => (
        <SongCard key={song.id} song={song} />
      ))}
    </li>
  );
}

export default SearchList;


--- src/app/search/_components/SearchResult/SearchList/index.ts ---
export { default } from "./SearchList";


--- src/app/search/_components/SearchResult/SearchLoading/SearchLoading.tsx ---
import LoadingSpinner from "@/components/common/LoadingSpinner";

interface SearchResultProps {
  isLoading: boolean;
}

function SearchLoading({ isLoading }: SearchResultProps) {
  return (
    <div className="fixed inset-0 flex items-center justify-center">
      <LoadingSpinner isLoading={isLoading} size={40} />
    </div>
  );
}

export default SearchLoading;


--- src/app/search/_components/SearchResult/SearchLoading/index.ts ---
export { default } from "./SearchLoading";


--- src/app/search/_components/SearchResult/_hooks/useSearch.ts ---
import { useCallback, useMemo, useRef } from "react";
import { SearchQueryParams, useSearchQuery } from "@/query/search/queries/useSearchQuery";
import { useIntersectionObserver } from "@/hooks/useIntersectionObserver";

export function useSearch(params: SearchQueryParams) {
  const loadMoreRef = useRef<HTMLDivElement>(null);

  const { data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, isError, error } =
    useSearchQuery(params);

  const handleIntersect = useCallback(() => {
    if (hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [fetchNextPage, hasNextPage, isFetchingNextPage]);

  useIntersectionObserver({
    target: loadMoreRef,
    onIntersect: handleIntersect,
    enabled: hasNextPage,
    rootMargin: "20%",
  });

  const searchTotal = data?.pages[0].data.total || 0;
  const songs = useMemo(() => {
    return data?.pages.flatMap((page) => page.data.items) || [];
  }, [data]);

  return {
    searchTotal,
    songs,
    isLoading,
    isError,
    error,
    isFetchingNextPage,
    hasNextPage,
    loadMoreRef,
  };
}


--- src/app/search/_components/SearchResult/SearchResult.tsx ---
"use client";

import { SearchPanelParams } from "@/types/search.type";
import { useSearch } from "@/app/search/_components/SearchResult/_hooks/useSearch";
import SearchLoading from "@/app/search/_components/SearchResult/SearchLoading";
import NotFound from "@/components/common/NotFound/NotFound";
import LoadingSpinner from "@/components/common/LoadingSpinner";
import SearchList from "@/app/search/_components/SearchResult/SearchList";

interface SearchResultProps {
  params: SearchPanelParams;
}

const DISPLAY_COUNT = 2;

function SearchResult({ params }: SearchResultProps) {
  if (!params || params.text === undefined) return null;

  const { loadMoreRef, isLoading, songs, isFetchingNextPage, searchTotal } = useSearch({
    ...params,
    text: params.text, // 그냥 params 넣으면 params.text 는 string 인게 검증되었는데도 뭐라고함
  });

  if (isLoading) return <SearchLoading isLoading={isLoading} />;

  if (!songs.length) return <NotFound text="Don't have any songs!" />;

  const displayLimit = songs.length - DISPLAY_COUNT;
  const displayedSongs = songs.slice(0, displayLimit);
  const overflowSongs = songs.slice(displayLimit);

  return (
    <div className="mt-2">
      <p className="mb-2 text-sm font-normal text-text-p">{searchTotal} results</p>
      <SearchList songs={displayedSongs} />
      <div ref={loadMoreRef} className="h-0 w-full py-3" />
      <SearchList songs={overflowSongs} />
      {isFetchingNextPage && <LoadingSpinner isLoading={isFetchingNextPage} />}
    </div>
  );
}

export default SearchResult;


--- src/app/search/_components/SearchResult/index.ts ---
export { default } from "./SearchResult";


--- src/app/search/page.tsx ---
"use server";

import SearchPanel from "@/app/search/_components/SearchPanel";
import SearchResult from "@/app/search/_components/SearchResult";
import { SearchPanelParams } from "@/types/search.type";

async function SearchPage({ searchParams }: { searchParams: Promise<SearchPanelParams> }) {
  const params = await searchParams;

  return (
    <div>
      <SearchPanel params={params} />
      <SearchResult params={params} />
    </div>
  );
}

export default SearchPage;


--- src/app/layout.tsx ---
import React from "react";
import "./globals.css";
import type { Metadata } from "next";
import { Manrope } from "next/font/google";
import { getServerSession } from "next-auth";
import SessionProvider from "@/app/_providers/SessionProvider";
import QueryProvider from "@/app/_providers/QueryProvider";
import TopNav from "@/app/_components/layout/TopNav";
import BottomNav from "@/app/_components/layout/BottomNav";
import { authOptions } from "@/lib/next-auth/nextAuth";
import ToastProvider from "@/components/ui/Toast/ToastContext";

const manrope = Manrope({
  variable: "--font-manrope",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

export const metadata: Metadata = {
  title: "App",
  description: "Generated by create next app",
};

async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const session = await getServerSession(authOptions);

  return (
    <html lang="ko" suppressHydrationWarning>
      <head>
        <script
          dangerouslySetInnerHTML={{
            __html: `
              try {
                const savedTheme = localStorage.getItem('theme');
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                const theme = savedTheme || (prefersDark ? 'dark' : 'light');
                document.documentElement.setAttribute('data-theme', theme);
              } catch (e) {}
            `,
          }}
        />
      </head>
      <body className={`${manrope.variable} antialiasing`}>
        <SessionProvider session={session}>
          <QueryProvider>
            <ToastProvider maxToasts={5}>
              <div className="flex h-screen flex-col">
                <TopNav />
                <main className="overflow-y-auto">
                  <div className="h-full px-4">{children}</div>
                </main>
                <BottomNav />
              </div>
            </ToastProvider>
          </QueryProvider>
        </SessionProvider>
      </body>
    </html>
  );
}

export default RootLayout;


--- src/app/page.tsx ---
"use client";

import Button from "@/components/ui/Button";
import Link from "next/link";
import { useToast } from "@/components/ui/Toast/useToast";
import FuckAccessToken from "@/app/_components/test/FuckAccessToken";
import GetMe from "@/app/_components/test/GetMe";
import LogoutMe from "@/app/_components/test/LogoutMe";

function HomePage() {
  const { toast } = useToast();

  const handleButtonClick = () => {
    toast({
      title: "알림",
      message: "작업이 완료되었습니다!",
      type: "error",
    });
  };

  return (
    <div className="flex flex-col gap-2">
      <Button>outline</Button>
      <Button variant="link">link</Button>
      <Button variant="ghost">ghost</Button>
      <Button variant="active" onClick={handleButtonClick}>
        active
      </Button>
      <Button variant="error" asChild>
        <Link href="/search">go to page Search</Link>
      </Button>
      <Button variant="link" asChild>
        <Link href="/login">go to page Login</Link>
      </Button>
      <FuckAccessToken />
      <GetMe />
      <LogoutMe />
    </div>
  );
}

export default HomePage;


--- src/components/common/Field/ErrorMessage/ErrorMessage.tsx ---
import { FieldError } from "react-hook-form";

function ErrorMessage({ error }: { error: FieldError | undefined }) {
  if (!error) return null;

  return <p className="text-button-error mt-1 text-sm">{error.message}</p>;
}

export default ErrorMessage;


--- src/components/common/Field/ErrorMessage/index.ts ---
export { default } from "./ErrorMessage";


--- src/components/common/Field/PasswordField/EyeButton/EyeButton.tsx ---
import React, { MouseEventHandler } from "react";
import { Eye, EyeOff } from "lucide-react";

interface EyeButtonProps {
  showPassword: boolean;
  togglePassword: MouseEventHandler<HTMLButtonElement>;
}

function EyeButton({ showPassword, togglePassword }: EyeButtonProps) {
  return (
    <button
      type="button"
      className="absolute right-4 top-1/2 -translate-y-1/2"
      onClick={togglePassword}
      aria-label={showPassword ? "Hide password" : "Show password"}
    >
      {showPassword ? (
        <EyeOff strokeWidth={1.5} size={24} className="text-icon-stroke" />
      ) : (
        <Eye strokeWidth={1.5} size={24} className="text-icon-stroke" />
      )}
    </button>
  );
}

export default EyeButton;


--- src/components/common/Field/PasswordField/EyeButton/index.ts ---
export { default } from "./EyeButton";


--- src/components/common/Field/PasswordField/hooks/useInvisiblePassword.ts ---
import { useState } from "react";

export function useInvisiblePassword() {
  const [showPassword, setShowPassword] = useState(false);

  const togglePassword = () => setShowPassword(!showPassword);

  return { showPassword, togglePassword };
}


--- src/components/common/Field/PasswordField/PasswordField.tsx ---
"use client";

import Input from "@/components/ui/Input";
import { FieldError, Path, UseFormRegister } from "react-hook-form";
import ErrorMessage from "@/components/common/Field/ErrorMessage";
import { useInvisiblePassword } from "@/components/common/Field/PasswordField/hooks/useInvisiblePassword";
import EyeButton from "@/components/common/Field/PasswordField/EyeButton";

interface PasswordFieldProps<T extends Record<string, any>> {
  id?: string;
  name: Path<T>;
  placeholder?: string;
  register: UseFormRegister<T>;
  error?: FieldError;
  className?: string;
}

function PasswordField<T extends Record<string, any>>({
  id = "password",
  name,
  placeholder = "Password",
  register,
  error,
  className,
}: PasswordFieldProps<T>) {
  const { showPassword, togglePassword } = useInvisiblePassword();

  return (
    <div>
      <div className={`relative ${className || ""}`}>
        <label htmlFor={id} />
        <Input
          id={id}
          type={showPassword ? "text" : "password"}
          placeholder={placeholder}
          {...register(name)}
        />
        <EyeButton showPassword={showPassword} togglePassword={togglePassword} />
      </div>
      <ErrorMessage error={error} />
    </div>
  );
}

export default PasswordField;


--- src/components/common/Field/PasswordField/index.ts ---
export { default } from "./PasswordField";


--- src/components/common/Field/TextField/TextField.tsx ---
"use client";

import { FieldError, Path, UseFormRegister } from "react-hook-form";
import Input from "@/components/ui/Input";
import ErrorMessage from "@/components/common/Field/ErrorMessage";

interface TextFieldProps<T extends Record<string, any>> {
  id: string;
  name: Path<T>;
  type?: string;
  placeholder?: string;
  register: UseFormRegister<T>;
  error?: FieldError;
  className?: string;
}

function TextField<T extends Record<string, any>>({
  id,
  name,
  type = "text",
  placeholder,
  register,
  error,
  className,
}: TextFieldProps<T>) {
  return (
    <div className={className}>
      <label htmlFor={id} />
      <Input id={id} type={type} placeholder={placeholder} {...register(name)} />
      <ErrorMessage error={error} />
    </div>
  );
}

export default TextField;


--- src/components/common/Field/TextField/index.ts ---
export { default } from "./TextField";


--- src/components/common/LoadingSpinner/LoadingSpinner.tsx ---
import { Loader } from "lucide-react";

interface LoadingSpinnerProps {
  isLoading: boolean;
  className?: string;
  size?: number;
}

function LoadingSpinner({ isLoading, className, size = 24 }: LoadingSpinnerProps) {
  if (!isLoading) return null;

  return (
    <div className={`${className} flex w-full items-center justify-center py-4`}>
      <Loader size={size} className="animate-rotate" />
    </div>
  );
}

export default LoadingSpinner;


--- src/components/common/LoadingSpinner/index.ts ---
export { default } from "./LoadingSpinner";


--- src/components/common/NotFound/NotFound.tsx ---
interface NotFoundProps {
  text?: string;
}

function NotFound({ text = "Not Found" }: NotFoundProps) {
  return (
    <div className="mt-32 flex items-center justify-center">
      <h1 className="text-2xl font-semibold text-text-h">{text}</h1>
    </div>
  );
}

export default NotFound;


--- src/components/common/NotFound/index.ts ---


--- src/components/common/SongCard/SongCard.tsx ---
import { SearchItems } from "@/types/search.type";
import Image from "next/image";
import Button from "@/components/ui/Button";

interface SongCardProps {
  song: SearchItems;
}

function SongCard({ song }: SongCardProps) {
  const title = song.title_ko || song.title_ja;
  const artist = song.artist_ko || song.artist_ja;

  return (
    <ul className="flex flex-row gap-1">
      <Image
        src={song.thumbnail_url || "asdf"}
        alt={`${artist}'s ${title} Image`}
        width={70}
        height={70}
        className="rounded-xl"
      />
      <div className="ml-3 flex w-full flex-col justify-between">
        <h1
          className="overflow-hidden text-ellipsis whitespace-nowrap text-text-h"
          style={{ maxWidth: "calc(152px + (187 - 152) * ((100vw - 365px) / 35))" }}
        >
          {title}
        </h1>
        <p
          className="overflow-hidden text-ellipsis whitespace-nowrap text-sm text-text-p"
          style={{ maxWidth: "calc(152px + (187 - 152) * ((100vw - 365px) / 35))" }}
        >
          {artist}
        </p>
        <div className="flex gap-2 text-sm">
          <p className="w-16 text-text-tj">TJ {song.tj_number}</p>
          <p className="text-text-ky">KY {song.kumyoung_number}</p>
        </div>
      </div>
      <Button variant="ghost" className="h-8 min-w-20 max-w-20 text-sm font-medium">
        Add
      </Button>
    </ul>
  );
}

export default SongCard;


--- src/components/common/SongCard/index.ts ---
export { default } from "./SongCard";


--- src/components/common/ThemeToggle/_hooks/useTheme.ts ---
"use client";

import { useEffect, useState } from "react";
import { applyTheme } from "@/utils/applyTheme";

type Theme = "light" | "dark";

export function useTheme() {
  const [theme, setTheme] = useState<Theme>("light");

  useEffect(() => {
    try {
      const currentTheme = document.documentElement.getAttribute("data-theme") as Theme;
      if (currentTheme) {
        setTheme(currentTheme);
      }
    } catch (error) {
      console.error("Error reading theme:", error);
    }
  }, []);

  useEffect(() => {
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = (e: MediaQueryListEvent) => {
      if (!localStorage.getItem("theme")) {
        const newTheme = e.matches ? "dark" : "light";
        setTheme(newTheme);
        applyTheme(newTheme);
      }
    };

    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, []);

  const toggleTheme = () => {
    const newTheme = theme === "light" ? "dark" : "light";
    setTheme(newTheme);
    applyTheme(newTheme);
  };

  return {
    theme,
    toggleTheme,
    isDark: theme === "dark",
  };
}


--- src/components/common/ThemeToggle/ThemeToggle.tsx ---
"use client";

import { useTheme } from "@/components/common/ThemeToggle/_hooks/useTheme";
import { MdLightMode, MdOutlineNightlightRound } from "react-icons/md";
import { useMounted } from "@/hooks/useMounted";

function ThemeToggle() {
  const { theme, toggleTheme } = useTheme();
  const { mounted } = useMounted();

  return (
    <button
      onClick={toggleTheme}
      className="relative h-10 max-h-10 w-10 rounded-md p-2 hover:bg-button-ghost"
      aria-label={`Switch to ${theme === "light" ? "dark" : "light"} mode`}
    >
      {theme === "light" && <MdOutlineNightlightRound size={24} color="black" />}
      {(theme !== "light" || !mounted) && (
        <MdLightMode
          size={24}
          color="white"
          className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2"
        />
      )}
    </button>
  );
}

export default ThemeToggle;


--- src/components/common/ThemeToggle/index.ts ---
export { default } from "./ThemeToggle";


--- src/components/ui/Button/Button.tsx ---
import React from "react";

const styles = {
  outline: "bg-button-outline border border-stroke-default",
  link: "bg-button-link",
  ghost: "bg-button-ghost",
  active: "bg-button-active text-text-white",
  error: "bg-button-error text-text-white",
} as const;

type ButtonVariant = keyof typeof styles;

interface ButtonProps extends React.ComponentProps<"button"> {
  variant?: ButtonVariant;
  asChild?: boolean;
}

function Button({
  children,
  onClick,
  variant = "outline",
  className,
  asChild = false,
  ...props
}: ButtonProps) {
  const buttonStyles = `${className || ""} ${styles[variant]} button-hover flex justify-center items-center bg-button-active text-text-h h-12 w-full rounded-xl text-base font-semibold transition-all duration-200`;

  if (asChild && React.isValidElement(children)) {
    const childProps = children.props as any;
    const childOnClick = childProps.onClick;

    const combinedOnClick =
      onClick || childOnClick
        ? (e: React.MouseEvent<Element, MouseEvent>) => {
            if (onClick) onClick(e as React.MouseEvent<HTMLButtonElement>);
            if (childOnClick) childOnClick(e);
          }
        : undefined;

    return React.cloneElement(children, {
      ...childProps,
      ...props,
      onClick: combinedOnClick,
      className: `${childProps.className || ""} ${buttonStyles}`,
    });
  }

  return (
    <button onClick={onClick} className={buttonStyles} {...props}>
      {children}
    </button>
  );
}

export default Button;


--- src/components/ui/Button/index.ts ---
export { default } from "./Button";


--- src/components/ui/Input/Input.tsx ---
import React from "react";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      className={`${className || ""}bg-input-input flex h-14 w-full items-center justify-center rounded-xl p-4 text-base text-text-h placeholder:text-text-p focus:outline-none focus:ring-1 focus:ring-solid-default`}
      {...props}
    />
  );
}

export default Input;


--- src/components/ui/Input/index.ts ---
export { default } from "./Input";


--- src/components/ui/Toast/Toast.tsx ---
"use client";

import React, { useEffect, useState } from "react";
import { X } from "lucide-react";

const TOAST_LIFETIME = 3 * 1000;

const styles = {
  success: "border-l-button-active text-button-active",
  error: "border-l-button-error text-button-error",
} as const;

export type ToastType = "success" | "error";

export interface ToastProps {
  id: string;
  title?: string;
  message: string;
  type?: ToastType;
  duration?: number;
  onClose: (id: string) => void;
}

function Toast({
  id,
  title,
  message,
  type = "success",
  duration = TOAST_LIFETIME,
  onClose,
}: ToastProps) {
  const [isHovered, setIsHovered] = useState(false);

  useEffect(() => {
    if (duration !== Infinity) {
      const timer = setTimeout(() => {
        onClose(id);
      }, duration);

      return () => clearTimeout(timer);
    }
  }, [id, duration, onClose]);

  return (
    <div
      className={`${styles[type]} animate-fadeIn border-1 mb-2 flex min-w-80 max-w-md items-start justify-between rounded-md border-l-4 border-stroke-default bg-body-default p-4 shadow-md`}
      role="alert"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onMouseUp={() => onClose(id)}
    >
      <div>
        {title && <h1 className="font-bold">{title}</h1>}
        <p className="text-sm text-text-p">{message}</p>
      </div>
      {isHovered && (
        <button
          className="absolute right-2 top-2 transition-opacity duration-200 focus:outline-none"
          onClick={(e) => {
            e.stopPropagation(); // 클릭 이벤트가 상위로 전파되는 것을 방지
            onClose(id);
          }}
          aria-label="닫기"
        >
          <X size={18} />
        </button>
      )}
    </div>
  );
}

export default Toast;


--- src/components/ui/Toast/ToastContainer.tsx ---
import Toast from "./Toast";
import { ToastItem } from "./ToastContext";

interface ToastContainerProps {
  toasts: ToastItem[];
  removeToast: (id: string) => void;
}

function ToastContainer({ toasts, removeToast }: ToastContainerProps) {
  return (
    <div className="fixed bottom-4 right-4 z-50 flex flex-col" aria-live="polite">
      {toasts.map((toast) => (
        <Toast
          key={toast.id}
          id={toast.id}
          title={toast.title}
          message={toast.message}
          type={toast.type}
          duration={toast.duration}
          onClose={removeToast}
        />
      ))}
    </div>
  );
}

export default ToastContainer;


--- src/components/ui/Toast/ToastContext.tsx ---
"use client";

import React, { createContext, ReactNode, useCallback, useState } from "react";
import ToastContainer from "./ToastContainer";
import { ToastType } from "./Toast";

export interface ToastItem {
  id: string;
  title?: string;
  message: string;
  type?: ToastType;
  duration?: number;
}

interface ToastContextType {
  toast: (options: Omit<ToastItem, "id">) => void;
  removeToast: (id: string) => void;
}

export const ToastContext = createContext<ToastContextType | undefined>(undefined);

interface ToastProviderProps {
  children: ReactNode;
  maxToasts?: number;
}

function ToastProvider({ children, maxToasts = 5 }: ToastProviderProps) {
  const [toasts, setToasts] = useState<ToastItem[]>([]);

  const toast = useCallback(
    (options: Omit<ToastItem, "id">) => {
      const newToast = {
        id: crypto.randomUUID(),
        ...options,
      };

      setToasts((prevToasts) => {
        const updatedToasts = [...prevToasts, newToast];
        if (updatedToasts.length > maxToasts) {
          return updatedToasts.slice(updatedToasts.length - maxToasts);
        }
        return updatedToasts;
      });

      return newToast.id;
    },
    [maxToasts]
  );

  const removeToast = useCallback((id: string) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ toast, removeToast }}>
      {children}
      <ToastContainer toasts={toasts} removeToast={removeToast} />
    </ToastContext.Provider>
  );
}

export default ToastProvider;


--- src/components/ui/Toast/useToast.ts ---
import { useContext } from "react";
import { ToastContext } from "./ToastContext";
import { ToastType } from "./Toast";

interface ToastOptions {
  title?: string;
  message: string;
  type?: ToastType;
  duration?: number;
}

export function useToast() {
  const context = useContext(ToastContext);

  if (context === undefined) {
    throw new Error("useToast must be used within a ToastProvider");
  }

  const { toast: showToast, removeToast } = context;

  const toast = Object.assign((options: ToastOptions) => showToast(options), {
    success: (message: string, title?: string, duration?: number) =>
      showToast({ message, title, type: "success", duration }),
    error: (message: string, title?: string, duration?: number) =>
      showToast({ message, title, type: "error", duration }),
    dismiss: (id: string) => removeToast(id),
  });

  return { toast };
}


--- src/hooks/useIntersectionObserver.ts ---
import { RefObject, useEffect } from "react";

interface UseIntersectionObserverProps {
  target: RefObject<Element | null>;
  onIntersect: () => void;
  enabled?: boolean;
  rootMargin?: string;
  threshold?: number;
}

export function useIntersectionObserver({
  target,
  onIntersect,
  enabled = true,
  rootMargin = "0px",
  threshold = 0.1,
}: UseIntersectionObserverProps) {
  useEffect(() => {
    if (!enabled || !target.current) return;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            onIntersect();
          }
        });
      },
      {
        rootMargin,
        threshold,
      }
    );

    const element = target.current;
    observer.observe(element);

    return () => {
      if (element) observer.unobserve(element);
    };
  }, [target, enabled, onIntersect, rootMargin, threshold]);
}


--- src/hooks/useMounted.ts ---
import { useEffect, useState } from "react";

export function useMounted() {
  const [mounted, setMounted] = useState(false);

  // 마운트 된 후에만 UI 렌더링
  useEffect(() => {
    setMounted(true);
  }, []);

  return { mounted };
}


--- src/hooks/useScrollRestoration.ts ---
import { useEffect, useState } from "react";

interface ScrollPosition {
  x: number;
  y: number;
}

export function useScrollRestoration(key: string = "default-scroll-position") {
  const [scrollPosition, setScrollPosition] = useState<ScrollPosition>(() => {
    if (typeof window === "undefined") return { x: 0, y: 0 };

    const saved = sessionStorage.getItem(`scroll-position-${key}`);
    return saved ? JSON.parse(saved) : { x: 0, y: 0 };
  });

  const saveScrollPosition = () => {
    const position = {
      x: window.scrollX,
      y: window.scrollY,
    };
    setScrollPosition(position);
    sessionStorage.setItem(`scroll-position-${key}`, JSON.stringify(position));
  };

  const restoreScrollPosition = () => {
    if (scrollPosition.y > 0) {
      window.scrollTo({
        top: scrollPosition.y,
        left: scrollPosition.x,
        behavior: "instant",
      });
    }
  };

  useEffect(() => {
    restoreScrollPosition();

    window.addEventListener("beforeunload", saveScrollPosition);
    return () => {
      window.removeEventListener("beforeunload", saveScrollPosition);
      saveScrollPosition();
    };
  }, []);

  return {
    scrollPosition,
    saveScrollPosition,
    restoreScrollPosition,
  };
}


--- src/lib/axios/instance.ts ---
import axios from "axios";
import { signIn, signOut } from "next-auth/react";
import { authApi } from "@/api/auth";
import { getIsomorphicSession } from "@/utils/getIsomorphicSession";

export const axiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  timeout: 5000,
  headers: {
    "Content-Type": "application/json",
    Accept: "application/json",
  },
});

axiosInstance.interceptors.request.use(
  async function (config) {
    try {
      const session = await getIsomorphicSession();

      if (session?.user?.accessToken) {
        config.headers.Authorization = `Bearer ${session.user.accessToken}`;
      }

      return config;
    } catch (error) {
      console.error("Request interceptor error:", error);
      return config;
    }
  },
  function (error) {
    return Promise.reject(error);
  }
);

const MAX_RETRIES = 3;

axiosInstance.interceptors.response.use(
  function (response) {
    return response;
  },
  async function (error) {
    const originalRequest = error.config;

    if (originalRequest._retry >= MAX_RETRIES) {
      await signOut({ redirect: true, callbackUrl: "/login" });
      return Promise.reject(error);
    }

    if (error.response && error.response.status === 401) {
      originalRequest._retry ??= 1;
      originalRequest._retry++;

      try {
        const session = await getIsomorphicSession();

        if (!session?.user?.refreshToken) {
          await signOut({ redirect: true, callbackUrl: "/login" });
          return Promise.reject(error);
        }

        const refreshToken = session.user.refreshToken;
        const data = await authApi.refresh(refreshToken);
        originalRequest.headers.Authorization = `Bearer ${data.accessToken}`;

        await signIn("Refresh", {
          accessToken: data.accessToken,
          refreshToken: data.refreshToken,
          redirect: false,
        });

        return axiosInstance(originalRequest);
      } catch (refreshError) {
        console.error(`${originalRequest._retry}th Failed:`, refreshError);
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);


--- src/lib/next-auth/nextAuth.ts ---
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { authApi } from "@/api/auth";

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        try {
          if (!credentials?.email || !credentials?.password) return null;

          const response = await authApi.login(credentials);

          const { user, accessToken, refreshToken } = response.data;

          if (user && accessToken) {
            return {
              accessToken,
              refreshToken,
              id: user.id,
              email: user.email,
              name: user.name,
              profile_image_url: user.profile_image_url,
            };
          }

          return null;
        } catch (error) {
          return null;
        }
      },
    }),
    CredentialsProvider({
      id: "Refresh",
      name: "Refresh",
      credentials: {
        refreshToken: { label: "RefreshToken", type: "refresh_token" },
        accessToken: { label: "AccessToken", type: "access_token" },
      },
      async authorize(credentials) {
        try {
          if (!credentials?.accessToken || !credentials?.refreshToken) return null;

          const { accessToken, refreshToken } = credentials;
          const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/users/me`, {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
              Authorization: `Bearer ${accessToken}`,
            },
          });

          const data = await response.json();

          return {
            accessToken,
            refreshToken,
            id: data.id,
            email: data.email,
            name: data.name,
            profile_image_url: data.profile_image_url,
          };
        } catch (error) {
          return null;
        }
      },
    }),
  ],
  events: {
    async signOut({ token }) {
      if (token?.accessToken) await authApi.logout(token.accessToken);
    },
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.accessToken = user.accessToken;
        token.refreshToken = user.refreshToken;
        token.id = Number(user.id);
        token.name = user.name;
        token.email = user.email;
        token.profile_image_url = user.profile_image_url;
      }
      return token;
    },
    async session({ session, token }) {
      if (token) {
        session.user = token;
      }
      return session;
    },
  },
  session: {
    strategy: "jwt",
    maxAge: 7 * 24 * 60 * 60,
  },
  // pages: {
  //   signIn: "/login",
  //   error: "/login",
  // },
  secret: process.env.NEXTAUTH_SECRET,
};


--- src/lib/next-auth/nextAuth.type.d.ts ---
import { DefaultSession } from "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      accessToken: string;
      refreshToken: string;
      id: number;
      name: string;
      email: string;
      profile_image_url: string | null;
    } & DefaultSession["user"];
  }

  interface User {
    accessToken: string;
    refreshToken: string;
    id: number;
    name: string;
    email: string;
    profile_image_url: string | null;
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    accessToken: string;
    refreshToken: string;
    id: number;
    name: string;
    email: string;
    profile_image_url: string | null;
  }
}


--- src/lib/zod/auth.ts ---
import { z } from "zod";

const email = z.string().min(1, "이메일을 입력해주세요").email("올바른 이메일 형식이 아닙니다");
const name = z.string().min(1, "이름을 입력해주세요");
const password = z
  .string()
  .min(1, "비밀번호를 입력해주세요")
  .min(8, "비밀번호는 8자 이상이어야 합니다");
const passwordConfirm = z.string().min(1, "비밀번호 확인을 입력해주세요");

export const loginSchema = z.object({
  email,
  password,
});

export const accountSchema = z
  .object({
    email,
    name,
    password,
    passwordConfirm,
  })
  .refine((data) => data.password === data.passwordConfirm, {
    message: "비밀번호가 일치하지 않습니다",
    path: ["passwordConfirm"],
  });

export type LoginSchema = z.infer<typeof loginSchema>;
export type AccountSchema = z.infer<typeof accountSchema>;


--- src/query/auth/mutations/useAccountMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { AccountRequest } from "@/types/auth.type";
import { authApi } from "@/api/auth";
import { useToast } from "@/components/ui/Toast/useToast";

export function useAccountMutation() {
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: AccountRequest) => authApi.account(data),
    onSuccess: () => {
      toast({
        title: "Account Login Success",
        message: "Account Login Successfully Great!",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Account Login Failed",
        message: `${error.message || "Account Login Failed Something went wrong!"}`,
        type: "error",
      });
    },
  });
}


--- src/query/auth/mutations/useLoginMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { LoginRequest } from "@/types/auth.type";
import { signIn } from "next-auth/react";
import { useToast } from "@/components/ui/Toast/useToast";

export function useLoginMutation() {
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: LoginRequest) => {
      const result = await signIn("credentials", {
        email: data.email,
        password: data.password,
        redirect: true,
        callbackUrl: "/",
      });

      if (result?.error) {
        throw new Error(result.error);
      }
    },
    onSuccess: () => {
      toast({
        title: "Login Success",
        message: "Login Successfully Great!",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Login Failed",
        message: `${error.message || "Login Failed So Sad.."}`,
        type: "error",
      });
    },
  });
}


--- src/query/auth/mutations/useLogoutMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { useToast } from "@/components/ui/Toast/useToast";
import { signOut } from "next-auth/react";

export function useLogoutMutation() {
  const { toast } = useToast();

  return useMutation({
    mutationFn: () => signOut({ redirect: true, callbackUrl: "/login" }),
    onSuccess: () => {
      toast({
        title: "Logout Success",
        message: "Logout Successfully Great!",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Logout Failed",
        message: `${error.message || "Logout Failed Stay Restored!"}`,
        type: "error",
      });
    },
  });
}


--- src/query/search/queries/useSearchQuery.ts ---
import { useInfiniteQuery } from "@tanstack/react-query";
import { getSearchQueryKey } from "@/query/search/key";
import { searchApi } from "@/api/search";
import { SearchPanelParams } from "@/types/search.type";

export type SearchQueryParams = SearchPanelParams & { text: string };

export function useSearchQuery(params: SearchQueryParams) {
  const { text, searchType, sort } = params;
  const limit = 10;

  return useInfiniteQuery({
    queryKey: getSearchQueryKey(params),
    queryFn: ({ pageParam = 1 }) =>
      searchApi({
        text,
        searchType,
        sort,
        page: pageParam,
        limit,
      }),
    initialPageParam: 1,
    getNextPageParam: (lastPage) => {
      const { total, page, limit } = lastPage.data;
      const loadedItems = page * limit;

      return loadedItems < total ? page + 1 : undefined;
    },
    enabled: text?.length > 0,
    refetchOnMount: false,
    refetchOnWindowFocus: false,
  });
}


--- src/query/search/key.ts ---
export const getSearchQueryKey = (params: {
  text?: string;
  searchType?: "both" | "artist" | "title" | "lyrics";
  sort?: "latest" | "popular";
}) => ["search", params.text, params.searchType, params.sort];


--- src/types/auth.type.ts ---
interface User {
  id: number;
  name: string;
  email: string;
  profile_image_url: string | null;
}

export interface AccountRequest {
  name: string;
  email: string;
  password: string;
}

export type AccountResponse = string;

export type LoginRequest = Omit<AccountRequest, "name">;

export interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  user: User;
}

export type LogoutResponse = string;

export type RefreshRequest = string;

export interface RefreshResponse {
  accessToken: string;
  refreshToken: string;
}


--- src/types/search.type.ts ---
export type SearchType = "both" | "artist" | "title" | "lyrics";
export type Sort = "latest" | "popular";

export interface SearchRequest {
  text?: string;
  searchType?: SearchType;
  sort?: Sort;
  limit?: number;
  page?: number;
}

export type SearchPanelParams = Omit<SearchRequest, "limit" | "page">;

export interface SearchItems {
  id: number;
  song_id: number;
  title_ko: string;
  title_ja?: string;
  title_en?: string;
  artist_id: number;
  release_date?: string;
  thumbnail_url: string | null;
  popularity_score: number;
  created_at: string;
  updated_at: string;
  artist_ko?: string;
  artist_ja?: string;
  artist_en?: string;
  romanized_ko?: string;
  tj_number?: string;
  kumyoung_number?: string;
}

export interface SearchResponse {
  items: SearchItems[];
  total: number;
  page: number;
  limit: number;
}


--- src/types/users.type.ts ---
interface MeResponse {
  id: number;
  name: string;
  email: string;
  profile_image_url: string;
  created_at: string;
  updated_at: string;
}

type AllResponse = MeResponse[];


--- src/utils/applyTheme.ts ---
type Theme = "light" | "dark";

export const applyTheme = (newTheme: Theme) => {
  if (typeof document !== "undefined") {
    document.documentElement.setAttribute("data-theme", newTheme);
    localStorage.setItem("theme", newTheme);
  }
};


--- src/utils/getIsomorphicSession.ts ---
import { getSession } from "next-auth/react";
import { getServerSession, Session } from "next-auth";
import { authOptions } from "@/lib/next-auth/nextAuth";

export const getIsomorphicSession = async (): Promise<Session | null> => {
  return typeof window === "undefined" ? await getServerSession(authOptions) : await getSession();
};


