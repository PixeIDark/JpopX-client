--- src/api/auth.ts ---
import { axiosInstance } from "@/lib/axios/instance";
import {
  AccountRequest,
  AccountResponse,
  LoginRequest,
  LoginResponse,
  RefreshRequest,
  RefreshResponse,
} from "@/types/auth.type";

const url = "auth";

export const authApi = {
  account: (data: AccountRequest) => axiosInstance.post<AccountResponse>(`${url}/signup`, data),

  login: async (data: LoginRequest) => {
    const response = await axiosInstance.post<LoginResponse>(`${url}/login`, data);
    return response.data;
  },

  logout: async (accessToken: string) => {
    try {
      await fetch(`${process.env.NEXT_PUBLIC_API_URL}/auth/logout`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${accessToken}`,
        },
      });
    } catch (error) {
      console.error(error);
      return Promise.reject(error);
    }
  },
  
  refresh: async (refreshToken: RefreshRequest): Promise<RefreshResponse> => {
    try {
      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/${url}/refresh`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
        },
        body: JSON.stringify({ refreshToken }),
      });

      return response.json();
    } catch (error) {
      console.error(error);
      return Promise.reject(error);
    }
  },
};


--- src/api/favorite-lists.ts ---
import { axiosInstance } from "@/lib/axios/instance";
import {
  AddSongToListRequest,
  AddSongToListResponse,
  CreateFavoriteListRequest,
  CreateFavoriteListResponse,
  DeleteFavoriteListResponse,
  GetFavoriteListSongsResponse,
  GetFavoriteListsResponse,
  RemoveSongFromListResponse,
  ReorderListRequest,
  ReorderListResponse,
  ReorderSongRequest,
  ReorderSongResponse,
  UpdateFavoriteListRequest,
  UpdateFavoriteListResponse,
} from "@/types/favorite-list.type";

const url = "favorites";

export const favoriteListsApi = {
  getLists: async () => {
    const response = await axiosInstance.get<GetFavoriteListsResponse>(`${url}/lists`);
    return response.data;
  },

  getListSongs: async (listId: number) => {
    const response = await axiosInstance.get<GetFavoriteListSongsResponse>(
      `${url}/lists/${listId}/songs`
    );
    return response.data;
  },

  createList: async (data: CreateFavoriteListRequest) => {
    const response = await axiosInstance.post<CreateFavoriteListResponse>(`${url}/lists`, data);
    return response.data;
  },

  updateList: async (listId: number, data: UpdateFavoriteListRequest) => {
    const response = await axiosInstance.put<UpdateFavoriteListResponse>(
      `${url}/lists/${listId}`,
      data
    );
    return response.data;
  },

  deleteList: async (listId: number) => {
    const response = await axiosInstance.delete<DeleteFavoriteListResponse>(
      `${url}/lists/${listId}`
    );
    return response.data;
  },

  reorderList: async (data: ReorderListRequest) => {
    const response = await axiosInstance.put<ReorderListResponse>(`${url}/lists/reorder`, data);
    return response.data;
  },

  addSongToList: async (listId: number, data: AddSongToListRequest) => {
    try {
      const response = await axiosInstance.post<AddSongToListResponse>(
        `${url}/lists/${listId}/songs`,
        data
      );
      return response.data;
    } catch (error) {
      console.error(error);
      return Promise.reject(error);
    }
  },

  removeSongFromList: async (favoriteId: number) => {
    const response = await axiosInstance.delete<RemoveSongFromListResponse>(
      `${url}/songs/${favoriteId}`
    );
    return response.data;
  },

  reorderSong: async (data: ReorderSongRequest) => {
    const response = await axiosInstance.put<ReorderSongResponse>(`${url}/songs/reorder`, data);
    return response.data;
  },
};


--- src/api/search.ts ---
import { axiosInstance } from "@/lib/axios/instance";
import { SearchRequest, SearchResponse } from "@/types/search.type";

const url = "search";

export const searchApi = async (params: SearchRequest) => {
  const response = await axiosInstance.get<SearchResponse>(url, {
    params: {
      text: params.text || "",
      searchType: params.searchType || "both",
      sort: params.sort || "popular",
      limit: params.limit || 20,
      page: params.page || 1,
    },
  });
  return response.data;
};


--- src/api/upload.ts ---
import { axiosInstance } from "@/lib/axios/instance";

interface UploadResponse {
  url: string;
}

export const upload = async (file: File) => {
  const formData = new FormData();
  formData.append("file", file);

  try {
    const response = await axiosInstance.post<UploadResponse>("/upload/single", formData, {
      headers: {
        "Content-Type": "multipart/form-data",
      },
    });

    return response.data;
  } catch (error) {
    console.error("Failed Image upload:", error);
    return Promise.reject(error);
  }
};


--- src/api/users.ts ---
import { axiosInstance } from "@/lib/axios/instance";
import { AllResponse, MeModifyRequest, MeModifyResponse, MeResponse } from "@/types/users.type";

const url = "users";

export const usersApi = {
  all: () => axiosInstance.get<AllResponse>(`${url}`),

  me: async () => {
    const response = await axiosInstance.get<MeResponse>(`${url}/me`);
    return response.data;
  },

  modify: async (data: MeModifyRequest) => {
    if (!data) return;

    const response = await axiosInstance.put<MeModifyResponse>(`${url}/me`, data);
    return response.data;
  },

  deleteAccount: async () => {
    const response = await axiosInstance.delete(`${url}/me`);
    return response.data;
  },
};


--- src/app/(auth)/account/_components/AccountForm/AccountForm.tsx ---
"use client";

import { useForm } from "react-hook-form";
import { accountSchema, AccountSchema } from "@/lib/zod/auth";
import { zodResolver } from "@hookform/resolvers/zod";
import TextField from "@/components/common/Field/TextField";
import PasswordField from "@/components/common/Field/PasswordField";
import Button from "@/components/ui/Button";
import { useAccountMutation } from "@/query/auth/mutations/useAccountMutation";

function AccountForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<AccountSchema>({
    resolver: zodResolver(accountSchema),
  });
  const { mutate: accountMutate } = useAccountMutation();

  const onSubmit = (data: AccountSchema) => accountMutate(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="mt-3 flex flex-col gap-6">
      <TextField
        id="name"
        name="name"
        type="text"
        error={errors.name}
        placeholder="Your name"
        register={register}
      />
      <TextField
        id="email"
        name="email"
        type="email"
        error={errors.email}
        placeholder="Email Address"
        register={register}
      />
      <PasswordField
        id="password"
        name="password"
        error={errors.password}
        placeholder="Password"
        register={register}
      />
      <PasswordField
        id="passwordConfirm"
        name="passwordConfirm"
        error={errors.passwordConfirm}
        placeholder="Confirm Password"
        register={register}
      />
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Loading" : "Account"}
      </Button>
    </form>
  );
}

export default AccountForm;


--- src/app/(auth)/account/_components/AccountForm/index.ts ---
export { default } from "./AccountForm";


--- src/app/(auth)/account/page.tsx ---
import AccountForm from "@/app/(auth)/account/_components/AccountForm";

function AccountPage() {
  return (
    <div>
      <AccountForm />
    </div>
  );
}

export default AccountPage;


--- src/app/(auth)/login/_components/LoginForm/LoginForm.tsx ---
"use client";

import { useForm } from "react-hook-form";
import { loginSchema, LoginSchema } from "@/lib/zod/auth";
import { zodResolver } from "@hookform/resolvers/zod";
import TextField from "@/components/common/Field/TextField";
import PasswordField from "@/components/common/Field/PasswordField";
import Button from "@/components/ui/Button";
import Link from "next/link";
import { useLoginMutation } from "@/query/auth/mutations/useLoginMutation";

function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginSchema>({
    resolver: zodResolver(loginSchema),
  });
  const { mutate: loginMutate } = useLoginMutation();

  const onSubmit = (data: LoginSchema) =>
    loginMutate({
      email: data.email,
      password: data.password,
    });

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="mt-3 flex flex-col gap-6">
      <TextField
        id="email"
        name="email"
        type="email"
        error={errors.email}
        placeholder="Email Address"
        register={register}
      />
      <PasswordField
        id="password"
        name="password"
        error={errors.password}
        placeholder="Password"
        register={register}
      />
      <p className="-mt-2 text-text-p">Forgot password?</p>
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Loading" : "Log in"}
      </Button>
      <Button type="submit" variant="link" asChild>
        <Link href="/account">New User Sign Up</Link>
      </Button>
    </form>
  );
}

export default LoginForm;


--- src/app/(auth)/login/_components/LoginForm/index.ts ---
export { default } from "./LoginForm";


--- src/app/(auth)/login/page.tsx ---
"use client";

import LoginForm from "@/app/(auth)/login/_components/LoginForm";
import { useSearchParams } from "next/navigation";
import { useToast } from "@/components/ui/Toast/useToast";
import { useEffect } from "react";

function LoginPage() {
  const params = useSearchParams();
  const { toast } = useToast();

  useEffect(() => {
    const toastText = params.get("toast");
    if (typeof toastText === "string") {
      toast({
        title: toastText,
        message: toastText,
        type: "error",
      });
    }
  }, [params]);

  return (
    <div>
      <LoginForm />
    </div>
  );
}

export default LoginPage;


--- src/app/(protected)/(lists)/_layout/CreateListButton/_hooks/useCreateListSubmit.ts ---
import { useCreateFavoriteListMutation } from "@/query/favorite-lists";
import { FormEvent, useRef, useState } from "react";

export function useCreateListSubmit() {
  const { mutate: createFavoriteListMutate } = useCreateFavoriteListMutation();
  const inputRef = useRef<HTMLInputElement>(null);
  const [dialogOpen, setDialogOpen] = useState(false);

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    const name = inputRef.current?.value.trim() || "";
    if (name.length > 0) {
      createFavoriteListMutate({ name });
      if (inputRef.current) {
        inputRef.current.value = "";
      }
      setDialogOpen(false);
    }
  };

  return { dialogOpen, setDialogOpen, inputRef, handleSubmit };
}


--- src/app/(protected)/(lists)/_layout/CreateListButton/CreateListButton.tsx ---
"use client";

import Button from "@/components/ui/Button";
import Dialog from "@/components/ui/Dialog";
import Input from "@/components/ui/Input";
import { useCreateListSubmit } from "@/app/(protected)/(lists)/_layout/CreateListButton/_hooks/useCreateListSubmit";

function CreateListButton() {
  const { dialogOpen, setDialogOpen, inputRef, handleSubmit } = useCreateListSubmit();

  return (
    <div className="fixed bottom-[77px] left-0 right-0 px-4 pb-3">
      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
        <Dialog.Trigger asChild>
          <Button variant="active">Create New List</Button>
        </Dialog.Trigger>
        <Dialog.Content>
          <form onClick={handleSubmit} className="flex flex-col gap-4">
            <h1 className="text-center">List Name</h1>
            <Input ref={inputRef} type="text" placeholder="Please Write" />
            <Button variant="active" className="mx-auto h-[40] w-20">
              Create
            </Button>
          </form>
        </Dialog.Content>
      </Dialog>
    </div>
  );
}

export default CreateListButton;


--- src/app/(protected)/(lists)/_layout/CreateListButton/index.ts ---
export { default } from "./CreateListButton";


--- src/app/(protected)/(lists)/add-list/[songId]/_components/AddToList/CheckFavoriteList/CheckFavoriteList.tsx ---
"use client";

import { Circle } from "lucide-react";

interface CheckFavoriteListProps {
  isChecked: boolean;
}

function CheckFavoriteList({ isChecked }: CheckFavoriteListProps) {
  return (
    <>
      {!isChecked ? (
        <Circle strokeWidth={1.5} className="stroke-icon-stroke" />
      ) : (
        <Circle strokeWidth={1.5} className="fill-icon-bg stroke-icon-stroke" />
      )}
    </>
  );
}

export default CheckFavoriteList;


--- src/app/(protected)/(lists)/add-list/[songId]/_components/AddToList/CheckFavoriteList/index.ts ---
export { default } from "./CheckFavoriteList";


--- src/app/(protected)/(lists)/add-list/[songId]/_components/AddToList/_hooks/useAddToListToggle.ts ---
import { useAddSongToListMutation, useRemoveSongFromListMutation } from "@/query/favorite-lists";
import { useState } from "react";

export function useAddToListToggle(listId: number, songId: number) {
  const { mutateAsync: addSongToListMutate } = useAddSongToListMutation(listId);
  const { mutate: removeSongFromListMutate } = useRemoveSongFromListMutation(listId);
  const [isChecked, setIsChecked] = useState(false);
  const [favoriteId, setFavoriteId] = useState<number | null>(null);

  const handleAddSongToList = async () => {
    const data = await addSongToListMutate({ songId });
    setFavoriteId(data.favorite_id);
    setIsChecked(true);
  };

  const handleRemoveSongFromList = () => {
    if (!favoriteId) return;
    removeSongFromListMutate(favoriteId);
    setFavoriteId(null);
    setIsChecked(false);
  };

  const handleToggle = () => {
    if (!isChecked) handleAddSongToList();
    else handleRemoveSongFromList();
  };

  return { isChecked, handleToggle };
}


--- src/app/(protected)/(lists)/add-list/[songId]/_components/AddToList/AddToList.tsx ---
"use client";

import { FavoriteList as List } from "@/types/favorite-list.type";
import Picture from "@/components/ui/Picture";
import CheckFavoriteList from "@/app/(protected)/(lists)/add-list/[songId]/_components/AddToList/CheckFavoriteList";
import { useAddToListToggle } from "@/app/(protected)/(lists)/add-list/[songId]/_components/AddToList/_hooks/useAddToListToggle";

interface FavoriteListProps {
  list: List;
  songId: number;
}

function AddToList({ list, songId }: FavoriteListProps) {
  const { isChecked, handleToggle } = useAddToListToggle(list.id, songId);

  return (
    <button onClick={handleToggle} className="flex items-center justify-between py-2">
      <div className="flex items-center gap-4">
        <Picture
          src={list.image_url}
          alt={`${list.name}'s image`}
          className="h-14 w-14 rounded-lg"
        />
        <div className="a flex flex-col justify-center">
          <h1 className="text-left text-base text-text-h">{list.name}</h1>
          <p className="text-sm text-text-p">{list.updated_at}</p>
        </div>
      </div>
      <CheckFavoriteList isChecked={isChecked} />
    </button>
  );
}

export default AddToList;


--- src/app/(protected)/(lists)/add-list/[songId]/_components/AddToList/index.ts ---
export { default } from "./AddToList";


--- src/app/(protected)/(lists)/add-list/[songId]/page.tsx ---
"use client";

import { useSuspenseQuery } from "@tanstack/react-query";
import { favoriteListsOption } from "@/query/favorite-lists/options/favoriteListsOption";
import { use } from "react";
import AddToList from "@/app/(protected)/(lists)/add-list/[songId]/_components/AddToList";

function AddListPage({ params }: { params: Promise<{ songId: string }> }) {
  const { data: lists } = useSuspenseQuery(favoriteListsOption);
  const { songId } = use(params);

  if (!lists || !songId) return null;

  const parsedSongId = parseInt(songId);

  return (
    <li className="flex flex-col">
      {lists.map((list) => (
        <AddToList key={list.id} list={list} songId={parsedSongId} />
      ))}
    </li>
  );
}

export default AddListPage;


--- src/app/(protected)/(lists)/mylist/[listId]/_components/FavoriteSongList/FavoirteSongCard/RemoveSongButton/RemoveSongButton.tsx ---
import { useRemoveSongFromListMutation } from "@/query/favorite-lists";
import Button from "@/components/ui/Button";

interface RemoveSongButtonProps {
  listId: number;
  favoriteId: number;
}

function RemoveSongButton({ listId, favoriteId }: RemoveSongButtonProps) {
  const { mutate: removeSongFromListMutate } = useRemoveSongFromListMutation(listId);

  const handleRemoveSong = () => removeSongFromListMutate(favoriteId);

  return (
    <Button
      onClick={handleRemoveSong}
      variant="ghost"
      className="h-8 min-w-20 max-w-20 text-sm font-medium"
    >
      Remove
    </Button>
  );
}

export default RemoveSongButton;


--- src/app/(protected)/(lists)/mylist/[listId]/_components/FavoriteSongList/FavoirteSongCard/RemoveSongButton/index.ts ---
export { default } from "./RemoveSongButton";


--- src/app/(protected)/(lists)/mylist/[listId]/_components/FavoriteSongList/FavoirteSongCard/FavoirteSongCard.tsx ---
import Picture from "@/components/ui/Picture";
import { FavoriteListSong } from "@/types/favorite-list.type";
import RemoveSongButton from "@/app/(protected)/(lists)/mylist/[listId]/_components/FavoriteSongList/FavoirteSongCard/RemoveSongButton";
import React from "react";

interface DragAndDropHandler {
  draggedItemId: number | null;
  handleDragStart: (id: number, order: number) => void;
  handleDragEnter: (order: number) => void;
  handleDragEnd: (userId: number) => void;
  handleDragOver: (e: React.DragEvent) => void;
}

interface SongCardProps {
  song: FavoriteListSong;
  listId: number;
  dragAndDropHandler: DragAndDropHandler;
}

function FavoriteSongCard({ song, listId, dragAndDropHandler }: SongCardProps) {
  const { draggedItemId, handleDragEnter, handleDragOver, handleDragStart, handleDragEnd } =
    dragAndDropHandler;
  const title = song.title_ko || song.title_ja;
  const artist = song.artist_ko || song.artist_ja;

  const isDragging = draggedItemId === listId;

  return (
    <ul
      draggable={true}
      onDragStart={() => handleDragStart(song.id, song.order)}
      onDragEnter={() => handleDragEnter(song.order)}
      onDragEnd={() => handleDragEnd(-1)}
      onDragOver={handleDragOver}
      className={`flex flex-row gap-1 py-3 transition-colors duration-200 ${isDragging ? "bg-button-ghost opacity-50" : ""} ${draggedItemId !== null && !isDragging ? "border-t-2 border-dashed border-solid-default" : ""} \`}`}
    >
      <div className="h-[70px] min-w-[70px]">
        <Picture
          src={song.thumbnail_url}
          alt={`${artist}'s ${title} Image`}
          className="h-full w-full rounded-xl object-fill"
        />
      </div>
      <div className="ml-3 flex w-full flex-col justify-between">
        <h1
          className="overflow-hidden text-ellipsis whitespace-nowrap text-text-h"
          style={{ maxWidth: "calc(152px + (187 - 152) * ((100vw - 365px) / 35))" }}
        >
          {title}
        </h1>
        <p
          className="overflow-hidden text-ellipsis whitespace-nowrap text-sm text-text-p"
          style={{ maxWidth: "calc(152px + (187 - 152) * ((100vw - 365px) / 35))" }}
        >
          {artist}
        </p>
        <div className="flex gap-2 text-sm">
          <p className="w-16 text-text-tj">TJ {song.tj_number}</p>
          <p className="text-text-ky">KY {song.kumyoung_number}</p>
        </div>
      </div>
      <RemoveSongButton listId={listId} favoriteId={song.id} />
    </ul>
  );
}

export default FavoriteSongCard;


--- src/app/(protected)/(lists)/mylist/[listId]/_components/FavoriteSongList/FavoirteSongCard/index.ts ---
export { default } from "./FavoirteSongCard";


--- src/app/(protected)/(lists)/mylist/[listId]/_components/FavoriteSongList/FavoriteSongList.tsx ---
"use client";

import { useFavoriteListSongsQuery, useReorderSongMutation } from "@/query/favorite-lists";
import FavoriteSongCard from "@/app/(protected)/(lists)/mylist/[listId]/_components/FavoriteSongList/FavoirteSongCard";
import { useDragAndDrop } from "@/hooks/useDragAndDrop";

interface FavoriteSongListProps {
  listId: number;
}

function FavoriteSongList({ listId }: FavoriteSongListProps) {
  const { data: list } = useFavoriteListSongsQuery(listId);
  const { mutate: reorderSongMutate } = useReorderSongMutation(listId);
  const dragAndDropHandler = useDragAndDrop(reorderSongMutate);

  if (!list) return null;

  return (
    <li className="flex flex-col">
      {list.map((song) => (
        <FavoriteSongCard
          key={song.id}
          song={song}
          listId={listId}
          dragAndDropHandler={dragAndDropHandler}
        />
      ))}
    </li>
  );
}

export default FavoriteSongList;


--- src/app/(protected)/(lists)/mylist/[listId]/_components/FavoriteSongList/index.ts ---
export { default } from "./FavoriteSongList";


--- src/app/(protected)/(lists)/mylist/[listId]/page.tsx ---
import { getServerQueryClient } from "@/lib/tanStackQuery/getServerQueryClient";
import { favoriteListSongsOption } from "@/query/favorite-lists/options/favoritListSongsOption";
import { dehydrate, HydrationBoundary } from "@tanstack/react-query";
import FavoriteSongList from "@/app/(protected)/(lists)/mylist/[listId]/_components/FavoriteSongList";

async function ListIdPage({ params }: { params: Promise<{ listId: string }> }) {
  const { listId } = await params;
  const parsedListId = parseInt(listId);

  const queryClient = getServerQueryClient();

  await queryClient.prefetchQuery(favoriteListSongsOption(parsedListId));

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <FavoriteSongList listId={parsedListId} />
    </HydrationBoundary>
  );
}

export default ListIdPage;


--- src/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled/DeleteList/DeleteList.tsx ---
import Button from "@/components/ui/Button";
import { useDeleteFavoriteListMutation } from "@/query/favorite-lists";

interface DeleteListProps {
  listId: number;
  onClose: () => void;
}

function DeleteList({ listId, onClose }: DeleteListProps) {
  const { mutate: deleteFavoriteList } = useDeleteFavoriteListMutation();

  const handleDelete = () => {
    deleteFavoriteList(listId);
    onClose();
  };

  return (
    <Button onClick={handleDelete} variant="link">
      Delete
    </Button>
  );
}

export default DeleteList;


--- src/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled/DeleteList/index.ts ---
export { default } from "./DeleteList";


--- src/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled/ModifyList/_hooks/useModifyList.ts ---
import { useUpdateFavoriteListMutation } from "@/query/favorite-lists";
import React, { useRef, useState } from "react";
import { StaticImageData } from "next/image";

interface ModifyListProps {
  listId: number;
  image: StaticImageData | string | null;
  onClose: () => void;
}

export function useModifyList({ listId, image, onClose }: ModifyListProps) {
  const { mutate: updateFavoriteList } = useUpdateFavoriteListMutation(listId);
  const inputRef = useRef<HTMLInputElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);

  const handleImageClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const newPreviewUrl = URL.createObjectURL(file);

      setSelectedFile(file);
      setPreviewUrl(newPreviewUrl);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    onClose();

    const name = inputRef.current?.value;
    if (!name || !name.length) return;

    const tempImageUrl = selectedFile ? URL.createObjectURL(selectedFile) : image;

    updateFavoriteList({
      name,
      image_url: tempImageUrl,
      isOptimistic: true,
      file: selectedFile,
    });
  };

  return { handleImageClick, handleFileChange, handleSubmit, previewUrl, fileInputRef, inputRef };
}


--- src/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled/ModifyList/ModifyList.tsx ---
import React from "react";
import Dialog from "@/components/ui/Dialog";
import Button from "@/components/ui/Button";
import Input from "@/components/ui/Input";
import { StaticImageData } from "next/image";
import Picture from "@/components/ui/Picture";
import { useModifyList } from "@/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled/ModifyList/_hooks/useModifyList";

interface ModifyListProps {
  listId: number;
  listName: string;
  image: StaticImageData | string | null;
  onClose: () => void;
}

function ModifyList({ listId, image, listName, onClose }: ModifyListProps) {
  const { handleImageClick, handleFileChange, handleSubmit, previewUrl, fileInputRef, inputRef } =
    useModifyList({
      listId,
      image,
      onClose,
    });

  return (
    <Dialog>
      <Dialog.Trigger asChild>
        <Button variant="link">Modify</Button>
      </Dialog.Trigger>
      <Dialog.Content>
        <form onSubmit={handleSubmit} className="flex flex-col gap-4">
          <h1 className="mx-auto">Change List</h1>
          <button type="button" className="mx-auto" onClick={handleImageClick}>
            <Picture
              src={previewUrl || image}
              alt="리스트 이미지"
              className="h-[200] w-[200] rounded-lg"
            />
            <p className="text-text-p">이미지 변경</p>
          </button>
          <input
            type="file"
            ref={fileInputRef}
            className="hidden"
            accept="image/*"
            onChange={handleFileChange}
          />
          <Input ref={inputRef} type="text" defaultValue={listName} />
          <Button type="submit" variant="active">
            Save
          </Button>
        </form>
      </Dialog.Content>
    </Dialog>
  );
}

export default ModifyList;


--- src/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled/ModifyList/index.ts ---
export { default } from "./ModifyList";


--- src/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled/ListControlled.tsx ---
"use client";

import { EllipsisVertical } from "lucide-react";
import Sheet from "@/components/ui/Sheet";
import ModifyList from "@/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled/ModifyList";
import DeleteList from "@/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled/DeleteList";
import { StaticImageData } from "next/image";
import { useState } from "react";

interface ListControlledProps {
  listId: number;
  listName: string;
  image: StaticImageData | string | null;
}

function ListControlled({ listId, image, listName }: ListControlledProps) {
  const [isOpen, setIsOpen] = useState(false);

  const handleClose = () => {
    setIsOpen(false);
  };

  return (
    <Sheet open={isOpen} onOpenChange={setIsOpen}>
      <Sheet.Trigger className="p-2">
        <EllipsisVertical width={24} height={24} />
      </Sheet.Trigger>
      <Sheet.Content>
        <div className="flex flex-col">
          <ModifyList listId={listId} image={image} listName={listName} onClose={handleClose} />
          <DeleteList listId={listId} onClose={handleClose} />
        </div>
      </Sheet.Content>
    </Sheet>
  );
}

export default ListControlled;


--- src/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled/index.ts ---
export { default } from "./ListControlled";


--- src/app/(protected)/(lists)/mylist/_components/FavoriteList/FavoriteList.tsx ---
"use client";

import { FavoriteList as List } from "@/types/favorite-list.type";
import Picture from "@/components/ui/Picture";
import Link from "next/link";
import ListControlled from "@/app/(protected)/(lists)/mylist/_components/FavoriteList/ListControlled";
import React from "react";
import { getTimeAgo } from "@/utils/getTimeAgo";

interface DragAndDropHandler {
  draggedItemId: number | null;
  handleDragStart: (id: number, order: number) => void;
  handleDragEnter: (order: number) => void;
  handleDragEnd: (userId: number) => void;
  handleDragOver: (e: React.DragEvent) => void;
}

interface FavoriteListProps {
  list: List;
  dragAndDropHandler: DragAndDropHandler;
  index: number;
}

function FavoriteList({ list, dragAndDropHandler, index }: FavoriteListProps) {
  const { draggedItemId, handleDragEnter, handleDragOver, handleDragStart, handleDragEnd } =
    dragAndDropHandler;

  const isDragging = draggedItemId === list.id;
  const updatedTime = getTimeAgo(list.updated_at);

  return (
    <div
      draggable={true}
      onDragStart={() => handleDragStart(list.id, list.order)}
      onDragEnter={() => handleDragEnter(list.order)}
      onDragEnd={() => handleDragEnd(list.user_id)}
      onDragOver={handleDragOver}
      className={`flex items-center justify-between transition-colors duration-200 ${isDragging ? "bg-button-ghost opacity-50" : ""} ${draggedItemId !== null && !isDragging ? "border-t-2 border-dashed border-solid-default" : ""} `}
      data-id={list.id}
      data-order={list.order}
      data-index={index}
    >
      <Link
        href={`/mylist/${list.id}`}
        className="flex w-full items-center justify-between py-2"
        onClick={(e) => isDragging && e.preventDefault()}
      >
        <div className="flex items-center gap-4">
          <Picture
            src={list.image_url}
            alt={`${list.name}'s image`}
            className="h-14 w-14 rounded-lg"
          />
          <div className="flex flex-col justify-center">
            <h1 className="text-left text-base text-text-h">{list.name}</h1>
            <p className="text-sm text-text-p">{updatedTime}</p>
          </div>
        </div>
      </Link>
      <ListControlled listId={list.id} image={list.image_url} listName={list.name} />
    </div>
  );
}

export default FavoriteList;


--- src/app/(protected)/(lists)/mylist/_components/FavoriteList/index.ts ---
export { default } from "./FavoriteList";


--- src/app/(protected)/(lists)/mylist/page.tsx ---
"use client";

import FavoriteList from "@/app/(protected)/(lists)/mylist/_components/FavoriteList";
import { useFavoriteListsQuery, useReorderFavoriteList } from "@/query/favorite-lists";
import { useDragAndDrop } from "@/hooks/useDragAndDrop";

function MyListPage() {
  const { data: lists } = useFavoriteListsQuery();
  const { mutate: reorderFavoriteList } = useReorderFavoriteList();
  const dragAndDropHandler = useDragAndDrop(reorderFavoriteList);

  if (!lists) return null;

  return (
    <div>
      {lists.map((list, index) => (
        <FavoriteList
          key={list.id}
          list={list}
          index={index}
          dragAndDropHandler={dragAndDropHandler}
        />
      ))}
    </div>
  );
}

export default MyListPage;


--- src/app/(protected)/(lists)/layout.tsx ---
"use server";

import React from "react";
import { getServerQueryClient } from "@/lib/tanStackQuery/getServerQueryClient";
import { favoriteListsOption } from "@/query/favorite-lists/options/favoriteListsOption";
import { dehydrate, HydrationBoundary } from "@tanstack/react-query";
import CreateListButton from "@/app/(protected)/(lists)/_layout/CreateListButton";

async function ListsLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const queryClient = getServerQueryClient();

  await queryClient.prefetchQuery(favoriteListsOption);

  return (
    <div className="relative">
      <HydrationBoundary state={dehydrate(queryClient)}>
        <div>{children}</div>
      </HydrationBoundary>
      <div className="h-[60] w-full" />
      <CreateListButton />
    </div>
  );
}

export default ListsLayout;


--- src/app/(protected)/profile/_components/ProfileImage/_hooks/useProfileImage.ts ---
import { useUpdateImageMutation } from "@/query/users";
import React, { useRef, useState } from "react";

export function useProfileImage() {
  const { mutate: updateImage, isPending: updateIsPending } = useUpdateImageMutation();
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);

  const handleImageClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0] || null;
    if (file) {
      setSelectedFile(file);
      const url = URL.createObjectURL(file);
      setPreviewUrl(url);
    }
  };

  const handleSave = () => {
    if (selectedFile) {
      updateImage({
        file: selectedFile,
      });
    }
    setSelectedFile(null);
  };

  const handleUndo = () => {
    setSelectedFile(null);
    setPreviewUrl(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  return {
    selectedFile,
    previewUrl,
    fileInputRef,
    updateIsPending,
    handleImageClick,
    handleFileChange,
    handleSave,
    handleUndo,
  };
}


--- src/app/(protected)/profile/_components/ProfileImage/ProfileImage.tsx ---
import React from "react";
import Picture from "@/components/ui/Picture";
import { Save, Undo2 } from "lucide-react";
import { useSession } from "next-auth/react";
import { useProfileImage } from "@/app/(protected)/profile/_components/ProfileImage/_hooks/useProfileImage";

function ProfileImage() {
  const { data: userData } = useSession();
  const {
    selectedFile,
    previewUrl,
    fileInputRef,
    updateIsPending,
    handleFileChange,
    handleSave,
    handleUndo,
    handleImageClick,
  } = useProfileImage();

  return (
    <div className="relative w-fit">
      <button onClick={handleImageClick} disabled={updateIsPending}>
        <Picture
          src={previewUrl || userData?.user.profile_image_url}
          className="h-32 w-32 rounded-full"
        />
      </button>
      <input
        type="file"
        ref={fileInputRef}
        onChange={handleFileChange}
        accept="image/*"
        className="hidden"
      />
      <button
        onClick={handleSave}
        disabled={updateIsPending || !selectedFile}
        className="absolute bottom-0 right-5 w-fit rounded-full border border-icon-bg"
      >
        <Save className="stroke-icon-stroke" />
      </button>
      {selectedFile && (
        <button
          onClick={handleUndo}
          className="absolute bottom-5 right-0 w-fit rounded-full border border-icon-bg"
        >
          <Undo2 className="stroke-icon-stroke" />
        </button>
      )}
    </div>
  );
}

export default ProfileImage;


--- src/app/(protected)/profile/_components/ProfileImage/index.ts ---
export { default } from "./ProfileImage";


--- src/app/(protected)/profile/change-name/page.tsx ---
"use client";

import Button from "@/components/ui/Button";
import Link from "next/link";
import { useForm } from "react-hook-form";
import { NameSchema, nameSchema } from "@/lib/zod/auth";
import { zodResolver } from "@hookform/resolvers/zod";
import TextField from "@/components/common/Field/TextField";
import { useSession } from "next-auth/react";
import { useUpdateNameMutation } from "@/query/users";

function ChangeNamePage() {
  const { data: userData } = useSession();
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<NameSchema>({
    resolver: zodResolver(nameSchema),
  });

  const { mutate: updateNameMutate, isPending } = useUpdateNameMutation();

  const onSubmit = (data: NameSchema) => {
    if (!data.name) return;

    updateNameMutate({
      data,
      email: userData?.user.email,
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <TextField
        id="name"
        name="name"
        type="text"
        placeholder="New Name"
        register={register}
        error={errors.name}
        className="py-3"
      />
      <div className="flex flex-col gap-3 py-3">
        <Button type="submit" variant="outline" disabled={isPending}>
          Changes
        </Button>
        <Button variant="link" asChild>
          <Link href="/profile">Cancel</Link>
        </Button>
      </div>
    </form>
  );
}

export default ChangeNamePage;


--- src/app/(protected)/profile/change-password/page.tsx ---
"use client";

import { useSession } from "next-auth/react";
import { useForm } from "react-hook-form";
import { passwordSchema, PasswordSchema } from "@/lib/zod/auth";
import { zodResolver } from "@hookform/resolvers/zod";
import Button from "@/components/ui/Button";
import Link from "next/link";
import PasswordField from "@/components/common/Field/PasswordField";
import { useUpdatePasswordMutation } from "@/query/users";

function ChangePassword() {
  const { data: userData } = useSession();
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<PasswordSchema>({
    resolver: zodResolver(passwordSchema),
  });

  const { mutate: updatePasswordMutate, isPending } = useUpdatePasswordMutation();

  const onSubmit = (data: PasswordSchema) => {
    if (!data.password) return;

    updatePasswordMutate({
      data,
      email: userData?.user.email,
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <PasswordField
        id="password"
        name="password"
        error={errors.password}
        placeholder="Password"
        register={register}
        className="py-3"
      />
      <PasswordField
        id="passwordConfirm"
        name="passwordConfirm"
        error={errors.passwordConfirm}
        placeholder="Confirm Password"
        register={register}
        className="py-3"
      />
      <div className="flex flex-col gap-3 py-3">
        <Button type="submit" variant="outline" disabled={isPending}>
          Changes
        </Button>
        <Button variant="link" asChild>
          <Link href="/profile">Cancel</Link>
        </Button>
      </div>
    </form>
  );
}

export default ChangePassword;


--- src/app/(protected)/profile/verification/[changeType]/page.tsx ---
"use client";

import Button from "@/components/ui/Button";
import { use } from "react";
import { useSession } from "next-auth/react";
import Link from "next/link";
import PasswordField from "@/components/common/Field/PasswordField";
import { useForm } from "react-hook-form";
import { validateSchema, ValidateSchema } from "@/lib/zod/auth";
import { zodResolver } from "@hookform/resolvers/zod";
import { useVerifyPasswordMutation } from "@/query/users";

function VerificationPage({ params }: { params: Promise<{ changeType: string }> }) {
  const { changeType } = use(params);
  const { data: userData } = useSession();
  const { mutate: verifyPasswordMutate, isPending } = useVerifyPasswordMutation();
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<ValidateSchema>({
    resolver: zodResolver(validateSchema),
  });

  const nextPath = changeType === "name" ? "change-name" : "change-password";

  const onSubmit = (data: ValidateSchema) => {
    if (!data.password) return;

    verifyPasswordMutate({
      email: userData?.user.email,
      password: data.password,
      redirectPath: `/profile/${nextPath}`,
      changeType,
    });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <PasswordField
        id="password"
        name="password"
        placeholder="Password Verification"
        register={register}
        error={errors.password}
        className="py-3"
      />
      <div className="flex flex-col gap-3 py-3">
        <Button type="submit" variant="outline" disabled={isPending}>
          Next
        </Button>
        <Button variant="link" asChild>
          <Link href="/profile">Cancel</Link>
        </Button>
      </div>
    </form>
  );
}

export default VerificationPage;


--- src/app/(protected)/profile/page.tsx ---
"use client";

import React from "react";
import { useSession } from "next-auth/react";
import Button from "@/components/ui/Button";
import Link from "next/link";
import { useLogoutMutation } from "@/query/auth/mutations/useLogoutMutation";
import { useDeleteAccountMutation } from "@/query/users/mutations/useDeleteAccountMutation";
import ProfileImage from "@/app/(protected)/profile/_components/ProfileImage";

function ProfilePage() {
  const { data: userData } = useSession();
  const { mutate: logoutMutate, isPending: logoutIsPending } = useLogoutMutation();
  const { mutate: deleteAccount, isPending: deleteAccountIsPending } = useDeleteAccountMutation();

  return (
    <div className="flex flex-col gap-3">
      <div className="flex flex-col gap-4 py-4">
        <ProfileImage />
        <div>
          <h1 className="text-xl font-medium text-text-h">{userData?.user.name}</h1>
          <p className="font-light text-text-p">{userData?.user.email}</p>
        </div>
      </div>
      <div className="flex flex-col gap-3">
        <Button variant="ghost" asChild>
          <Link href="/profile/verification/name">Change Name</Link>
        </Button>
        <Button variant="ghost" asChild>
          <Link href="/profile/verification/password">Change Password</Link>
        </Button>
        <Button onClick={() => logoutMutate()} disabled={logoutIsPending} variant="outline">
          Log Out
        </Button>
        <Button onClick={() => deleteAccount()} disabled={deleteAccountIsPending} variant="error">
          Delete Account
        </Button>
      </div>
    </div>
  );
}

export default ProfilePage;


--- src/app/(public)/_components/PopularityList/PopularityList.tsx ---
"use client";

import { useSuspenseQuery } from "@tanstack/react-query";
import { searchQueryOption } from "@/query/search/options/searchQueryOption";
import SongCard from "@/components/common/SongCard";

function PopularityList() {
  const { data: songs } = useSuspenseQuery(
    searchQueryOption({ text: " ", searchType: "both", sort: "popular" })
  );

  return (
    <li className="flex flex-col gap-6">
      {songs.items.map((song) => (
        <SongCard key={song.id} song={song} />
      ))}
    </li>
  );
}

export default PopularityList;


--- src/app/(public)/_components/PopularityList/index.ts ---
export { default } from "./PopularityList";


--- src/app/(public)/search/_components/SearchPanel/SearchFilter/SearchFilter.tsx ---
import Button from "@/components/ui/Button";
import React from "react";
import { SearchType } from "@/types/search.type";
import { useQueryParamState } from "@/hooks/useQueryParamState";

interface SearchFilterProps {
  initialSearchType: SearchType;
}

const SEARCH_TYPES = ["both", "title", "artist"] as const;

function SearchFilter({ initialSearchType }: SearchFilterProps) {
  const { choiceParam, applyQueryParams } = useQueryParamState(initialSearchType, "search");

  return (
    <div className="flex gap-3">
      {SEARCH_TYPES.map((type, idx) => (
        <Button
          key={idx}
          variant={choiceParam === type ? "outline" : "ghost"}
          value={type}
          onClick={applyQueryParams}
          className="h-11 max-w-[70px] text-sm"
        >
          {type}
        </Button>
      ))}
    </div>
  );
}

export default SearchFilter;


--- src/app/(public)/search/_components/SearchPanel/SearchFilter/index.ts ---
export { default } from "./SearchFilter";


--- src/app/(public)/search/_components/SearchPanel/SearchInput/SearchInput.tsx ---
"use client";

import Input from "@/components/ui/Input";
import { useQueryInput } from "@/hooks/useQueryInput";

interface SearchInputProps {
  initialText: string;
}

function SearchInput({ initialText }: SearchInputProps) {
  const { handleSubmit, inputRef } = useQueryInput(initialText, "text");

  return (
    <form onSubmit={handleSubmit} className="w-full">
      <Input
        placeholder="Please Enter Something"
        ref={inputRef}
        type="text"
        defaultValue={initialText}
      />
    </form>
  );
}

export default SearchInput;


--- src/app/(public)/search/_components/SearchPanel/SearchInput/index.ts ---
export { default } from "./SearchInput";


--- src/app/(public)/search/_components/SearchPanel/SearchSort/SearchSort.tsx ---
"use client";

import Button from "@/components/ui/Button";
import { Sort } from "@/types/search.type";
import React from "react";
import { useQueryParamState } from "@/hooks/useQueryParamState";

interface SearchSortProps {
  initialSort: Sort;
}

const SORT_TYPES = ["popular", "latest"] as const;

function SearchSort({ initialSort }: SearchSortProps) {
  const { choiceParam, applyQueryParams } = useQueryParamState(initialSort, "search");

  return (
    <div className="flex rounded-xl bg-button-ghost p-1">
      {SORT_TYPES.map((sort, idx) => (
        <Button
          key={idx}
          variant={choiceParam === sort ? "link" : "ghost"}
          value={sort}
          onClick={applyQueryParams}
          className="h-8"
        >
          {sort}
        </Button>
      ))}
    </div>
  );
}

export default SearchSort;


--- src/app/(public)/search/_components/SearchPanel/SearchSort/index.ts ---


--- src/app/(public)/search/_components/SearchPanel/SearchPanel.tsx ---
"use client";

import SearchInput from "@/app/(public)/search/_components/SearchPanel/SearchInput";
import SearchFilter from "@/app/(public)/search/_components/SearchPanel/SearchFilter";
import { SearchPanelParams } from "@/types/search.type";
import SearchSort from "@/app/(public)/search/_components/SearchPanel/SearchSort/SearchSort";

interface SearchPanelProps {
  params: SearchPanelParams;
}

function SearchPanel({ params }: SearchPanelProps) {
  const { text = "", searchType = "both", sort = "popular" } = params;

  return (
    <div className="mt-3 flex flex-col gap-3">
      <SearchInput initialText={text} />
      <SearchFilter initialSearchType={searchType} />
      <SearchSort initialSort={sort} />
    </div>
  );
}

export default SearchPanel;


--- src/app/(public)/search/_components/SearchPanel/index.ts ---
export { default } from "./SearchPanel";


--- src/app/(public)/search/_components/SearchResult/SearchList/SearchList.tsx ---
import { SearchItems } from "@/types/search.type";
import SongCard from "@/components/common/SongCard";

interface SearchListProps {
  songs: SearchItems[];
}

function SearchList({ songs }: SearchListProps) {
  return (
    <li className="flex flex-col gap-6">
      {songs.map((song) => (
        <SongCard key={song.id} song={song} />
      ))}
    </li>
  );
}

export default SearchList;


--- src/app/(public)/search/_components/SearchResult/SearchList/index.ts ---
export { default } from "./SearchList";


--- src/app/(public)/search/_components/SearchResult/SearchLoading/SearchLoading.tsx ---
import LoadingSpinner from "@/components/common/LoadingSpinner";

interface SearchResultProps {
  isLoading: boolean;
}

function SearchLoading({ isLoading }: SearchResultProps) {
  return (
    <div className="fixed inset-0 flex items-center justify-center">
      <LoadingSpinner isLoading={isLoading} size={40} />
    </div>
  );
}

export default SearchLoading;


--- src/app/(public)/search/_components/SearchResult/SearchLoading/index.ts ---
export { default } from "./SearchLoading";


--- src/app/(public)/search/_components/SearchResult/_hooks/useSearch.ts ---
import { useCallback, useRef } from "react";
import { useIntersectionObserver } from "@/hooks/useIntersectionObserver";
import { SearchQueryParams, useSearchQuery } from "@/query/search";

export function useSearch(params: SearchQueryParams) {
  const loadMoreRef = useRef<HTMLDivElement>(null);

  const { data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, isError, error } =
    useSearchQuery(params);

  const handleIntersect = useCallback(() => {
    if (hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [fetchNextPage, hasNextPage, isFetchingNextPage]);

  useIntersectionObserver({
    target: loadMoreRef,
    onIntersect: handleIntersect,
    enabled: hasNextPage,
    rootMargin: "20%",
  });

  const searchTotal = data?.pages[0]?.total || 0;
  const songs = data?.pages.flatMap((page) => page.items) || [];

  return {
    searchTotal,
    songs,
    isLoading,
    isError,
    error,
    isFetchingNextPage,
    hasNextPage,
    loadMoreRef,
  };
}


--- src/app/(public)/search/_components/SearchResult/SearchResult.tsx ---
"use client";

import { SearchPanelParams } from "@/types/search.type";
import { useSearch } from "@/app/(public)/search/_components/SearchResult/_hooks/useSearch";
import SearchLoading from "@/app/(public)/search/_components/SearchResult/SearchLoading";
import NotFound from "@/components/common/NotFound/NotFound";
import LoadingSpinner from "@/components/common/LoadingSpinner";
import SearchList from "@/app/(public)/search/_components/SearchResult/SearchList";

interface SearchResultProps {
  params: SearchPanelParams;
}

const DISPLAY_COUNT = 2;

function SearchResult({ params }: SearchResultProps) {
  const { loadMoreRef, isLoading, songs, isFetchingNextPage, searchTotal } = useSearch({
    ...params,
    text: params.text || "",
  });

  if (isLoading) return <SearchLoading isLoading={isLoading} />;
  if (!songs.length) return <NotFound text="Don't have any songs!" />;

  const displayLimit = Math.max(0, songs.length - DISPLAY_COUNT);
  const displayedSongs = songs.slice(0, displayLimit);
  const overflowSongs = songs.slice(displayLimit);

  return (
    <div className="mt-2">
      <p className="mb-2 text-sm font-normal text-text-p">{searchTotal} results</p>
      {displayedSongs.length > 0 && <SearchList songs={displayedSongs} />}
      <div ref={loadMoreRef} className="h-0 w-full py-3" />
      {overflowSongs.length > 0 && <SearchList songs={overflowSongs} />}
      {isFetchingNextPage && <LoadingSpinner isLoading={isFetchingNextPage} />}
    </div>
  );
}

export default SearchResult;


--- src/app/(public)/search/_components/SearchResult/index.ts ---
export { default } from "./SearchResult";


--- src/app/(public)/search/page.tsx ---
import { dehydrate, HydrationBoundary } from "@tanstack/react-query";
import { getServerQueryClient } from "@/lib/tanStackQuery/getServerQueryClient";
import SearchPanel from "@/app/(public)/search/_components/SearchPanel";
import SearchResult from "@/app/(public)/search/_components/SearchResult";
import { SearchPanelParams } from "@/types/search.type";
import { searchQueryOption } from "@/query/search/options/searchQueryOption";

export default async function SearchPage({
  searchParams,
}: {
  searchParams: Promise<SearchPanelParams>;
}) {
  const params = await searchParams;
  const queryClient = getServerQueryClient();

  if (params.text) {
    await queryClient.prefetchQuery(searchQueryOption(params));
  }

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <div>
        <SearchPanel params={params} />
        <SearchResult params={params} />
      </div>
    </HydrationBoundary>
  );
}


--- src/app/(public)/page.tsx ---
import { getServerQueryClient } from "@/lib/tanStackQuery/getServerQueryClient";
import { searchQueryOption } from "@/query/search/options/searchQueryOption";
import { dehydrate, HydrationBoundary } from "@tanstack/react-query";
import React from "react";
import PopularityList from "@/app/(public)/_components/PopularityList";

async function HomePage() {
  const queryClient = getServerQueryClient();

  await queryClient.prefetchQuery(
    searchQueryOption({ text: " ", searchType: "both", sort: "popular" })
  );

  return (
    <div>
      <h1 className="py-2 text-center text-text-p">Top 10</h1>
      <HydrationBoundary state={dehydrate(queryClient)}>
        <PopularityList />
      </HydrationBoundary>
    </div>
  );
}

export default HomePage;


--- src/app/_layout/BottomNav/BottomNavItem/BottomNavItem.tsx ---
"use client";

import React from "react";
import { usePathname } from "next/navigation";
import Link from "next/link";

interface BottomNavItemProps {
  path: string;
  label: string;
  Icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;
  IconFill?: React.ComponentType<React.SVGProps<SVGSVGElement>>;
}

function BottomNavItem({ item }: { item: BottomNavItemProps }) {
  const pathname = usePathname();

  const isActive = item.path === pathname;
  return (
    <Link href={item.path} className="flex w-16 flex-col items-center justify-center gap-1">
      {isActive ? (
        item.IconFill && <item.IconFill width={24} height={24} className="fill-icon-bg" />
      ) : (
        <item.Icon width={24} height={24} className="fill-icon-stroke" />
      )}
      <p className="text-xs text-text-p">{item.label}</p>
    </Link>
  );
}

export default BottomNavItem;


--- src/app/_layout/BottomNav/BottomNavItem/index.ts ---
export { default } from "./BottomNavItem";


--- src/app/_layout/BottomNav/BottomNav.tsx ---
"use client";

import Home from "@/assets/icons/home/home.svg";
import HomeFill from "@/assets/icons/home/home_fill.svg";
import Search from "@/assets/icons/search/search.svg";
import SearchFill from "@/assets/icons/search/search_fill.svg";
import MyList from "@/assets/icons/myLists/myLists.svg";
import MyListFill from "@/assets/icons/myLists/myLists_fill.svg";
import Profile from "@/assets/icons/profile/profile.svg";
import BottomNavItem from "@/app/_layout/BottomNav/BottomNavItem";
import { useSelectedLayoutSegments } from "next/navigation";

const NAV_ITEMS = [
  {
    path: "/",
    label: "Home",
    Icon: Home,
    IconFill: HomeFill,
  },
  {
    path: "/search",
    label: "Search",
    Icon: Search,
    IconFill: SearchFill,
  },
  {
    path: "/mylist",
    label: "My List",
    Icon: MyList,
    IconFill: MyListFill,
  },
  {
    path: "/profile",
    label: "Profile",
    Icon: Profile,
  },
] as const;

function BottomNav() {
  const segment = useSelectedLayoutSegments();
  if (segment[0] === "(auth)" || segment[1] === "profile") return null;
  return (
    <div>
      <div className="pt fixed bottom-0 flex w-full items-center justify-between border-t border-solid-default bg-body-default px-4 pb-3 pt-5">
        {NAV_ITEMS.map((item) => (
          <BottomNavItem key={item.path} item={item} />
        ))}
      </div>
      <div className="h-[77px] w-full" />
    </div>
  );
}

export default BottomNav;


--- src/app/_layout/BottomNav/index.ts ---
export { default } from "./BottomNav";


--- src/app/_layout/Main/Main.tsx ---
"use client";
import { useEffect, useRef, useState } from "react";

function Main({ children }: { children: React.ReactNode }) {
  const mainRef = useRef<HTMLElement>(null);
  const [hasScrollbar, setHasScrollbar] = useState(false);

  useEffect(() => {
    const checkForScrollbar = () => {
      if (mainRef.current) {
        const hasVerticalScrollbar = mainRef.current.scrollHeight > mainRef.current.clientHeight;
        setHasScrollbar(hasVerticalScrollbar);
      }
    };

    checkForScrollbar();

    window.addEventListener("resize", checkForScrollbar);

    const observer = new MutationObserver(checkForScrollbar);

    if (mainRef.current) {
      observer.observe(mainRef.current, {
        childList: true,
        subtree: true,
      });
    }

    return () => {
      window.removeEventListener("resize", checkForScrollbar);
      observer.disconnect();
    };
  }, []);

  return (
    <main ref={mainRef} className={`overflow-y-auto pl-4 ${hasScrollbar ? "pr-3" : "pr-4"}`}>
      {children}
    </main>
  );
}

export default Main;


--- src/app/_layout/Main/index.ts ---
export { default } from "./Main";


--- src/app/_layout/TopNav/ThemeToggle/ThemeToggle.tsx ---
"use client";

import { useTransition } from "react";
import { useRouter } from "next/navigation";
import { MdLightMode, MdOutlineNightlightRound } from "react-icons/md";
import { setTheme } from "@/utils/theme";

interface ThemeToggleProps {
  currentTheme: "light" | "dark";
}

function ThemeToggle({ currentTheme }: ThemeToggleProps) {
  const router = useRouter();
  const [isPending, startTransition] = useTransition();

  const toggleTheme = async () => {
    const newTheme = currentTheme === "light" ? "dark" : "light";

    await setTheme(newTheme);

    startTransition(() => {
      router.refresh();
    });
  };

  return (
    <button
      onClick={toggleTheme}
      disabled={isPending}
      className="relative h-10 max-h-10 w-10 rounded-md p-2 hover:bg-button-ghost"
      aria-label={`Switch to ${currentTheme === "light" ? "dark" : "light"} mode`}
    >
      {currentTheme === "light" ? (
        <MdOutlineNightlightRound size={24} className="text-text-h" />
      ) : (
        <MdLightMode size={24} className="text-text-h" />
      )}
    </button>
  );
}

export default ThemeToggle;


--- src/app/_layout/TopNav/ThemeToggle/index.ts ---
export { default } from "./ThemeToggle";


--- src/app/_layout/TopNav/TopNav.tsx ---
"use client";

import { ArrowLeft } from "lucide-react";
import { usePathname, useRouter } from "next/navigation";
import Link from "next/link";
import ThemeToggle from "@/app/_layout/TopNav/ThemeToggle";

const NAV_TITLE = {
  "/": "Home",
  "/login": "Login",
  "/account": "Account",
  "/search": "Search",
  "/add-list": "Add List",
  "/mylist": "MyList",
  "/profile": "Profile",
} as const;

interface TopNavProps {
  currentTheme: "light" | "dark";
}

function TopNav({ currentTheme }: TopNavProps) {
  const pathname = usePathname();
  const router = useRouter();

  const title =
    NAV_TITLE[pathname as keyof typeof NAV_TITLE] ||
    NAV_TITLE[`/${pathname.split("/")[1]}` as keyof typeof NAV_TITLE] ||
    "Unknown Page";

  return (
    <div className="pt sticky top-0 flex items-center justify-between bg-body-default px-4 pb-3 pt-5">
      <button onClick={() => router.back()} className="p-2">
        <ArrowLeft size={24} strokeWidth={1.5} />
      </button>
      <Link href="/">
        <h1 className="text-lg font-semibold text-text-h">{title}</h1>
      </Link>
      <ThemeToggle currentTheme={currentTheme} />
    </div>
  );
}

export default TopNav;


--- src/app/_layout/TopNav/index.ts ---
export { default } from "./TopNav";


--- src/app/_providers/QueryProvider.tsx ---
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { ReactQueryStreamedHydration } from "@tanstack/react-query-next-experimental";
import { useState } from "react";
import { DEFAULT_QUERY_OPTIONS } from "@/lib/tanStackQuery/queryConfig";

function QueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            ...DEFAULT_QUERY_OPTIONS,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryStreamedHydration>{children}</ReactQueryStreamedHydration>
      <ReactQueryDevtools initialIsOpen={false} buttonPosition="bottom-left" />
    </QueryClientProvider>
  );
}

export default QueryProvider;


--- src/app/_providers/ScrollPositionProvider.tsx ---
"use client";

import React, { useCallback, useEffect, useRef } from "react";

export function ScrollPositionProvider({ children }: { children: React.ReactNode }) {
  const mainRef = useRef<HTMLDivElement | null>(null);
  const previousUrlRef = useRef<string>("");

  const loadScroll = useCallback(() => {
    if (!mainRef.current) return;

    const scrollKey = `scroll_${window.location.href}`;
    const scrollValue = sessionStorage.getItem(scrollKey);

    if (scrollValue && Number(scrollValue) > 0) {
      mainRef.current.scrollTop = Number(scrollValue);
    }
  }, []);

  useEffect(() => {
    const mainElement = document.querySelector("main.overflow-y-auto");
    if (mainElement) mainRef.current = mainElement as HTMLDivElement;

    const updateScrollInUrl = () => {
      if (mainRef.current) {
        const scrollValue = Math.round(mainRef.current.scrollTop);
        if (scrollValue > 0) {
          const scrollKey = `scroll_${window.location.href}`;
          sessionStorage.setItem(scrollKey, scrollValue.toString());
        }

        previousUrlRef.current = window.location.href;
      }
      return true;
    };

    const handlePopState = () => {
      if (mainRef.current) {
        const scrollValue = Math.round(mainRef.current.scrollTop);
        if (scrollValue > 0) {
          const scrollKey = `scroll_${previousUrlRef.current}`;
          sessionStorage.setItem(scrollKey, scrollValue.toString());
        }

        previousUrlRef.current = window.location.href;

        setTimeout(loadScroll, 50);
      }
      return true;
    };

    document.addEventListener("click", updateScrollInUrl, { passive: true });
    window.addEventListener("popstate", handlePopState);

    return () => {
      document.removeEventListener("click", updateScrollInUrl);
      window.removeEventListener("popstate", handlePopState);
    };
  }, [loadScroll]);

  return <>{children}</>;
}


--- src/app/_providers/SessionProvider.tsx ---
"use client";

import React from "react";
import { SessionProvider as Provider } from "next-auth/react";

interface SessionProviderProps {
  children: React.ReactNode;
  session: any;
}

function SessionProvider({ children, session }: SessionProviderProps) {
  return <Provider session={session}>{children}</Provider>;
}

export default SessionProvider;


--- src/app/api/auth/[...nextauth]/route.ts ---
import NextAuth from "next-auth";
import { authOptions } from "@/lib/next-auth/nextAuth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


--- src/app/test/_components/test/FuckAccessToken.tsx ---
import Button from "@/components/ui/Button";
import { getSession, signIn } from "next-auth/react";

function FuckAccessToken() {
  const a = async () => {
    const session = await getSession();
    console.log(session);
    const result = await signIn("Refresh", {
      refreshToken: session?.user.refreshToken,
      accessToken: "f",
      redirect: false,
    });
  };

  return <Button onClick={a}>Fuck AccessToken!</Button>;
}

export default FuckAccessToken;


--- src/app/test/_components/test/GetMe.tsx ---
import Button from "@/components/ui/Button";
import { usersApi } from "@/api/users";

function GetMe() {
  const a = async () => {
    const b = await usersApi.me();
    console.log(b);
  };

  return <Button onClick={a}>Get me</Button>;
}

export default GetMe;


--- src/app/test/_components/test/LogoutMe.tsx ---
import Button from "@/components/ui/Button";
import { getSession, signOut } from "next-auth/react";

function LogoutMe() {
  const a = async () => {
    let session = await getSession();
    console.log(session);
    await signOut({ redirect: false });
    session = await getSession();
    console.log(session);
  };

  return <Button onClick={a}>log out</Button>;
}

export default LogoutMe;


--- src/app/test/page.tsx ---
"use client";

import React from "react";
import { useToast } from "@/components/ui/Toast/useToast";
import Button from "@/components/ui/Button";
import Link from "next/link";
import FuckAccessToken from "@/app/test/_components/test/FuckAccessToken";
import GetMe from "@/app/test/_components/test/GetMe";
import LogoutMe from "@/app/test/_components/test/LogoutMe";

function TestPage() {
  const { toast } = useToast();

  const handleButtonClick = () => {
    toast({
      title: "알림",
      message: "작업이 완료되었습니다!",
      type: "error",
    });
  };

  return (
    <div className="flex flex-col gap-2">
      <Button>outline</Button>
      <Button variant="link">link</Button>
      <Button variant="ghost">ghost</Button>
      <Button variant="active" onClick={handleButtonClick}>
        active
      </Button>
      <Button variant="error" asChild>
        <Link href="/search">go to page Search</Link>
      </Button>
      <Button variant="link" asChild>
        <Link href="/login">go to page Login</Link>
      </Button>
      <FuckAccessToken />
      <GetMe />
      <LogoutMe />
    </div>
  );
}

export default TestPage;


--- src/app/layout.tsx ---
import React from "react";
import "./globals.css";
import type { Metadata } from "next";
import { Manrope } from "next/font/google";
import { getServerSession } from "next-auth";
import SessionProvider from "@/app/_providers/SessionProvider";
import QueryProvider from "@/app/_providers/QueryProvider";
import TopNav from "@/app/_layout/TopNav";
import BottomNav from "@/app/_layout/BottomNav";
import { authOptions } from "@/lib/next-auth/nextAuth";
import ToastProvider from "@/components/ui/Toast/ToastContext";
import { ScrollPositionProvider } from "@/app/_providers/ScrollPositionProvider";
import { getTheme } from "@/utils/theme";
import Main from "@/app/_layout/Main";

const manrope = Manrope({
  variable: "--font-manrope",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

export const metadata: Metadata = {
  title: "App",
  description: "Generated by create next app",
};

async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const theme = await getTheme();
  const session = await getServerSession(authOptions);

  return (
    <html lang="ko" data-theme={theme} suppressHydrationWarning>
      <body className={`${manrope.variable} antialiasing`}>
        <SessionProvider session={session}>
          <QueryProvider>
            <ToastProvider maxToasts={5}>
              <ScrollPositionProvider>
                <div className="flex h-screen flex-col">
                  <TopNav currentTheme={theme} />
                  <Main>{children}</Main>
                  <BottomNav />
                </div>
              </ScrollPositionProvider>
            </ToastProvider>
          </QueryProvider>
        </SessionProvider>
      </body>
    </html>
  );
}

export default RootLayout;


--- src/components/common/Field/ErrorMessage/ErrorMessage.tsx ---
import { FieldError } from "react-hook-form";

function ErrorMessage({ error }: { error: FieldError | undefined }) {
  if (!error) return null;

  return <p className="mt-1 text-sm text-button-error">{error.message}</p>;
}

export default ErrorMessage;


--- src/components/common/Field/ErrorMessage/index.ts ---
export { default } from "./ErrorMessage";


--- src/components/common/Field/PasswordField/EyeButton/EyeButton.tsx ---
import React, { MouseEventHandler } from "react";
import { Eye, EyeOff } from "lucide-react";

interface EyeButtonProps {
  showPassword: boolean;
  togglePassword: MouseEventHandler<HTMLButtonElement>;
}

function EyeButton({ showPassword, togglePassword }: EyeButtonProps) {
  return (
    <button
      type="button"
      className="absolute right-4 top-1/2 -translate-y-1/2"
      onClick={togglePassword}
      aria-label={showPassword ? "Hide password" : "Show password"}
    >
      {showPassword ? (
        <EyeOff strokeWidth={1.5} size={24} className="text-icon-stroke" />
      ) : (
        <Eye strokeWidth={1.5} size={24} className="text-icon-stroke" />
      )}
    </button>
  );
}

export default EyeButton;


--- src/components/common/Field/PasswordField/EyeButton/index.ts ---
export { default } from "./EyeButton";


--- src/components/common/Field/PasswordField/hooks/useInvisiblePassword.ts ---
import { useState } from "react";

export function useInvisiblePassword() {
  const [showPassword, setShowPassword] = useState(false);

  const togglePassword = () => setShowPassword(!showPassword);

  return { showPassword, togglePassword };
}


--- src/components/common/Field/PasswordField/PasswordField.tsx ---
"use client";

import Input from "@/components/ui/Input";
import { FieldError, Path, UseFormRegister } from "react-hook-form";
import ErrorMessage from "@/components/common/Field/ErrorMessage";
import { useInvisiblePassword } from "@/components/common/Field/PasswordField/hooks/useInvisiblePassword";
import EyeButton from "@/components/common/Field/PasswordField/EyeButton";

interface PasswordFieldProps<T extends Record<string, any>> {
  id?: string;
  name: Path<T>;
  placeholder?: string;
  register: UseFormRegister<T>;
  error?: FieldError;
  className?: string;
}

function PasswordField<T extends Record<string, any>>({
  id = "password",
  name,
  placeholder = "Password",
  register,
  error,
  className,
}: PasswordFieldProps<T>) {
  const { showPassword, togglePassword } = useInvisiblePassword();

  return (
    <div>
      <div className={`relative ${className || ""}`}>
        <label htmlFor={id} />
        <Input
          id={id}
          type={showPassword ? "text" : "password"}
          placeholder={placeholder}
          {...register(name)}
        />
        <EyeButton showPassword={showPassword} togglePassword={togglePassword} />
      </div>
      <ErrorMessage error={error} />
    </div>
  );
}

export default PasswordField;


--- src/components/common/Field/PasswordField/index.ts ---
export { default } from "./PasswordField";


--- src/components/common/Field/TextField/TextField.tsx ---
"use client";

import { FieldError, Path, UseFormRegister } from "react-hook-form";
import Input from "@/components/ui/Input";
import ErrorMessage from "@/components/common/Field/ErrorMessage";

interface TextFieldProps<T extends Record<string, any>> {
  id: string;
  name: Path<T>;
  type?: string;
  placeholder?: string;
  register: UseFormRegister<T>;
  error?: FieldError;
  className?: string;
}

function TextField<T extends Record<string, any>>({
  id,
  name,
  type = "text",
  placeholder,
  register,
  error,
  className,
}: TextFieldProps<T>) {
  return (
    <div className={className}>
      <label htmlFor={id} />
      <Input id={id} type={type} placeholder={placeholder} {...register(name)} />
      <ErrorMessage error={error} />
    </div>
  );
}

export default TextField;


--- src/components/common/Field/TextField/index.ts ---
export { default } from "./TextField";


--- src/components/common/LoadingSpinner/LoadingSpinner.tsx ---
import { Loader } from "lucide-react";

interface LoadingSpinnerProps {
  isLoading: boolean;
  className?: string;
  size?: number;
}

function LoadingSpinner({ isLoading, className, size = 24 }: LoadingSpinnerProps) {
  if (!isLoading) return null;

  return (
    <div className={`${className} flex w-full items-center justify-center py-4`}>
      <Loader size={size} className="animate-rotate" />
    </div>
  );
}

export default LoadingSpinner;


--- src/components/common/LoadingSpinner/index.ts ---
export { default } from "./LoadingSpinner";


--- src/components/common/NotFound/NotFound.tsx ---
interface NotFoundProps {
  text?: string;
}

function NotFound({ text = "Not Found" }: NotFoundProps) {
  return (
    <div className="mt-32 flex items-center justify-center">
      <h1 className="text-2xl font-semibold text-text-h">{text}</h1>
    </div>
  );
}

export default NotFound;


--- src/components/common/NotFound/index.ts ---


--- src/components/common/SongCard/SongCard.tsx ---
import { SearchItems } from "@/types/search.type";
import Button from "@/components/ui/Button";
import Picture from "@/components/ui/Picture";
import Link from "next/link";

interface SongCardProps {
  song: SearchItems;
}

function SongCard({ song }: SongCardProps) {
  const title = song.title_ko || song.title_ja;
  const artist = song.artist_ko || song.artist_ja;

  return (
    <ul className="flex flex-row gap-1">
      <div className="h-[70px] min-w-[70px]">
        <Picture
          src={song.thumbnail_url}
          alt={`${artist}'s ${title} Image`}
          className="h-full w-full rounded-xl object-fill"
        />
      </div>
      <div className="ml-3 flex w-full flex-col justify-between">
        <h1
          className="overflow-hidden text-ellipsis whitespace-nowrap text-text-h"
          style={{ maxWidth: "calc(152px + (187 - 152) * ((100vw - 365px) / 35))" }}
        >
          {title}
        </h1>
        <p
          className="overflow-hidden text-ellipsis whitespace-nowrap text-sm text-text-p"
          style={{ maxWidth: "calc(152px + (187 - 152) * ((100vw - 365px) / 35))" }}
        >
          {artist}
        </p>
        <div className="flex gap-2 text-sm">
          <p className="w-16 text-text-tj">TJ {song.tj_number}</p>
          <p className="text-text-ky">KY {song.kumyoung_number}</p>
        </div>
      </div>
      <Button variant="ghost" className="h-8 min-w-20 max-w-20 text-sm font-medium" asChild>
        <Link href={`/add-list/${song.song_id}`}>Add</Link>
      </Button>
    </ul>
  );
}

export default SongCard;


--- src/components/common/SongCard/index.ts ---
export { default } from "./SongCard";


--- src/components/ui/Button/Button.tsx ---
import React from "react";

const styles = {
  outline: "bg-button-outline border border-stroke-default",
  link: "bg-button-link",
  ghost: "bg-button-ghost",
  active: "bg-button-active text-text-white",
  error: "bg-button-error text-text-white",
} as const;

type ButtonVariant = keyof typeof styles;

interface ButtonProps extends React.ComponentProps<"button"> {
  variant?: ButtonVariant;
  asChild?: boolean;
}

function Button({
  children,
  onClick,
  variant = "outline",
  className,
  asChild = false,
  ...props
}: ButtonProps) {
  const buttonStyles = `${className || ""} ${styles[variant]} button-hover flex justify-center items-center bg-button-active text-text-h h-12 w-full rounded-xl text-base font-semibold transition-all duration-200`;

  if (asChild && React.isValidElement(children)) {
    const childProps = children.props as any;
    const childOnClick = childProps.onClick;

    const combinedOnClick =
      onClick || childOnClick
        ? (e: React.MouseEvent<Element, MouseEvent>) => {
            if (onClick) onClick(e as React.MouseEvent<HTMLButtonElement>);
            if (childOnClick) childOnClick(e);
          }
        : undefined;

    return React.cloneElement(children, {
      ...childProps,
      ...props,
      onClick: combinedOnClick,
      className: `${childProps.className || ""} ${buttonStyles}`,
    });
  }

  return (
    <button onClick={onClick} className={buttonStyles} {...props}>
      {children}
    </button>
  );
}

export default Button;


--- src/components/ui/Button/index.ts ---
export { default } from "./Button";


--- src/components/ui/Dialog/Dialog.tsx ---
import React, { createContext, useContext, useEffect, useState } from "react";
import { X } from "lucide-react";

type DialogContextType = {
  isOpen: boolean;
  onOpen: () => void;
  onClose: () => void;
};

const initialDialogContext: DialogContextType = {
  isOpen: false,
  onOpen: () => {},
  onClose: () => {},
};

const DialogContext = createContext(initialDialogContext);
const useDialogContext = () => useContext(DialogContext);

interface DialogProps {
  children: React.ReactNode;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}

function Dialog({ children, open, onOpenChange }: DialogProps) {
  const [internalOpen, setInternalOpen] = useState(false);

  const isControlled = open !== undefined;
  const isOpen = isControlled ? open : internalOpen;

  useEffect(() => {
    if (isControlled) {
      setInternalOpen(open);
    }
  }, [isControlled, open]);

  const handleOpen = () => {
    if (!isControlled) {
      setInternalOpen(true);
    }
    onOpenChange?.(true);
  };

  const handleClose = () => {
    if (!isControlled) {
      setInternalOpen(false);
    }
    onOpenChange?.(false);
  };

  const value = {
    isOpen,
    onOpen: handleOpen,
    onClose: handleClose,
  };

  return <DialogContext.Provider value={value}>{children}</DialogContext.Provider>;
}

interface TriggerProps {
  children: React.ReactNode;
  className?: string;
  asChild?: boolean;
}

function Trigger({ children, className, asChild = false, ...props }: TriggerProps) {
  const { onOpen } = useDialogContext();

  if (asChild && React.isValidElement(children)) {
    return React.cloneElement(children, {
      onClick: onOpen,
      ...props,
    } as React.HTMLAttributes<HTMLElement>);
  }

  return (
    <button className={className} onClick={onOpen} {...props}>
      {children}
    </button>
  );
}

interface ContentProps {
  children: React.ReactNode;
  className?: string;
}

function Content({ children, className }: ContentProps) {
  const { isOpen, onClose } = useDialogContext();

  useEffect(() => {
    const handleEscKey = (event: KeyboardEvent) => {
      if (isOpen && event.key === "Escape") onClose();
    };

    document.addEventListener("keydown", handleEscKey);
    return () => document.removeEventListener("keydown", handleEscKey);
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  const handleOutClose = (e: React.MouseEvent<HTMLDivElement>) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <div
      className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/50"
      onClick={handleOutClose}
    >
      <div className={`${className || ""} relative w-full max-w-md rounded-xl bg-body-default p-4`}>
        <div>{children}</div>
        <button onClick={onClose} className="absolute right-4 top-4" aria-label="닫기">
          <X className="stroke-icon-stroke" />
        </button>
      </div>
    </div>
  );
}

Dialog.Trigger = Trigger;
Dialog.Content = Content;
export default Dialog;


--- src/components/ui/Dialog/index.ts ---
export { default } from "./Dialog";


--- src/components/ui/Input/Input.tsx ---
import React from "react";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      className={`${className || ""} flex h-14 w-full items-center justify-center rounded-xl bg-input-input p-4 text-base text-text-h placeholder:text-text-p focus:outline-none focus:ring-1 focus:ring-solid-default`}
      {...props}
    />
  );
}

export default Input;


--- src/components/ui/Input/index.ts ---
export { default } from "./Input";


--- src/components/ui/Picture/Picture.tsx ---
"use client";

import React, { useEffect, useState } from "react";
import { StaticImageData } from "next/image";
import errorImage from "@/assets/images/src_error.png";
import notFoundImage from "@/assets/images/src_notfound.png";

interface PictureProps extends Omit<React.ImgHTMLAttributes<HTMLImageElement>, "src"> {
  src?: StaticImageData | string | null;
  fallbackSrc?: StaticImageData | string;
  width?: number;
  height?: number;
}

function Picture({ src, alt, fallbackSrc = errorImage, width, height, ...props }: PictureProps) {
  const [currentSrc, setCurrentSrc] = useState<string>(() => {
    if (!src) return typeof notFoundImage === "string" ? notFoundImage : notFoundImage.src;
    return typeof src === "string" ? src : src.src;
  });

  useEffect(() => {
    if (!src) {
      setCurrentSrc(typeof notFoundImage === "string" ? notFoundImage : notFoundImage.src);
    } else {
      setCurrentSrc(typeof src === "string" ? src : src.src);
    }
  }, [src]);

  const handleError = () => {
    const fallbackSrcValue = typeof fallbackSrc === "string" ? fallbackSrc : fallbackSrc.src;
    setCurrentSrc(fallbackSrcValue);
  };

  return (
    <img
      src={currentSrc}
      alt={alt || "이미지"}
      onError={handleError}
      loading="lazy"
      width={width}
      height={height}
      {...props}
    />
  );
}

export default Picture;


--- src/components/ui/Picture/index.ts ---
export { default } from "./Picture";


--- src/components/ui/Sheet/Sheet.tsx ---
import React, { createContext, useContext, useEffect, useState } from "react";
import { Minus } from "lucide-react";

const initialValues = {
  isOpen: false,
  onOpen: () => {},
  onClose: () => {},
};

const SheetContext = createContext(initialValues);
const useSheetContext = () => useContext(SheetContext);

interface SheetProps {
  children: React.ReactNode;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}

function Sheet({ children, open, onOpenChange }: SheetProps) {
  const [internalOpen, setInternalOpen] = useState(false);
  const isControlled = open !== undefined;
  const isOpen = isControlled ? open : internalOpen;

  useEffect(() => {
    if (isControlled) {
      setInternalOpen(open);
    }
  }, [isControlled, open]);

  const handleOpen = () => {
    if (!isControlled) {
      setInternalOpen(true);
    }
    onOpenChange?.(true);
  };

  const handleClose = () => {
    if (!isControlled) {
      setInternalOpen(false);
    }
    onOpenChange?.(false);
  };

  const value = {
    isOpen,
    onOpen: handleOpen,
    onClose: handleClose,
  };

  return <SheetContext.Provider value={value}>{children}</SheetContext.Provider>;
}

interface TriggerProps {
  children: React.ReactNode;
  asChild?: boolean;
  className?: string;
}

function Trigger({ children, asChild = false, className = "", ...props }: TriggerProps) {
  const { onOpen } = useSheetContext();

  if (asChild && React.isValidElement(children)) {
    return React.cloneElement(children, {
      onClick: onOpen,
      ...props,
    } as React.HTMLAttributes<HTMLElement>);
  }

  return (
    <button className={className} onClick={onOpen} {...props}>
      {children}
    </button>
  );
}

interface ContentProps {
  children: React.ReactNode;
  className?: string;
}

function Content({ children, className = "" }: ContentProps) {
  const { isOpen, onClose } = useSheetContext();

  if (!isOpen) return null;

  const handleOutClose = (e: React.MouseEvent<HTMLDivElement>) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  };

  return (
    <div className="fixed inset-0 z-40 bg-black/50" onClick={handleOutClose}>
      <div
        className={`${className} absolute inset-x-0 bottom-0 mx-auto w-full max-w-md rounded-xl bg-body-default p-4`}
      >
        <button onClick={onClose} className="absolute inset-x-0 top-0" aria-label="닫기">
          <Minus className="mx-auto stroke-button-ghost" />
        </button>
        <div>{children}</div>
      </div>
    </div>
  );
}

Sheet.Trigger = Trigger;
Sheet.Content = Content;
export default Sheet;


--- src/components/ui/Sheet/index.ts ---
export { default } from "./Sheet";


--- src/components/ui/Toast/Toast.tsx ---
"use client";

import React, { useEffect, useState } from "react";
import { X } from "lucide-react";

const TOAST_LIFETIME = 3 * 1000;

const styles = {
  success: "border-l-button-active text-button-active",
  error: "border-l-button-error text-button-error",
} as const;

export type ToastType = "success" | "error";

export interface ToastProps {
  id: string;
  title?: string;
  message: string;
  type?: ToastType;
  duration?: number;
  onClose: (id: string) => void;
}

function Toast({
  id,
  title,
  message,
  type = "success",
  duration = TOAST_LIFETIME,
  onClose,
}: ToastProps) {
  const [isHovered, setIsHovered] = useState(false);

  useEffect(() => {
    if (duration !== Infinity) {
      const timer = setTimeout(() => {
        onClose(id);
      }, duration);

      return () => clearTimeout(timer);
    }
  }, [id, duration, onClose]);

  return (
    <div
      className={`${styles[type]} animate-fadeIn border-1 mb-2 flex min-w-80 max-w-md items-start justify-between rounded-md border-l-4 border-stroke-default bg-body-default p-4 shadow-md`}
      role="alert"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onMouseUp={() => onClose(id)}
    >
      <div>
        {title && <h1 className="font-bold">{title}</h1>}
        <p className="text-sm text-text-p">{message}</p>
      </div>
      {isHovered && (
        <button
          className="absolute right-2 top-2 transition-opacity duration-200 focus:outline-none"
          onClick={(e) => {
            e.stopPropagation(); // 클릭 이벤트가 상위로 전파되는 것을 방지
            onClose(id);
          }}
          aria-label="닫기"
        >
          <X size={18} />
        </button>
      )}
    </div>
  );
}

export default Toast;


--- src/components/ui/Toast/ToastContainer.tsx ---
import Toast from "./Toast";
import { ToastItem } from "./ToastContext";

interface ToastContainerProps {
  toasts: ToastItem[];
  removeToast: (id: string) => void;
}

function ToastContainer({ toasts, removeToast }: ToastContainerProps) {
  return (
    <div className="fixed bottom-4 right-4 z-50 flex flex-col" aria-live="polite">
      {toasts.map((toast) => (
        <Toast
          key={toast.id}
          id={toast.id}
          title={toast.title}
          message={toast.message}
          type={toast.type}
          duration={toast.duration}
          onClose={removeToast}
        />
      ))}
    </div>
  );
}

export default ToastContainer;


--- src/components/ui/Toast/ToastContext.tsx ---
"use client";

import React, { createContext, ReactNode, useCallback, useState } from "react";
import ToastContainer from "./ToastContainer";
import { ToastType } from "./Toast";

export interface ToastItem {
  id: string;
  title?: string;
  message: string;
  type?: ToastType;
  duration?: number;
}

interface ToastContextType {
  toast: (options: Omit<ToastItem, "id">) => void;
  removeToast: (id: string) => void;
}

export const ToastContext = createContext<ToastContextType | undefined>(undefined);

interface ToastProviderProps {
  children: ReactNode;
  maxToasts?: number;
}

function ToastProvider({ children, maxToasts = 5 }: ToastProviderProps) {
  const [toasts, setToasts] = useState<ToastItem[]>([]);

  const toast = useCallback(
    (options: Omit<ToastItem, "id">) => {
      const newToast = {
        id: crypto.randomUUID(),
        ...options,
      };

      setToasts((prevToasts) => {
        const updatedToasts = [...prevToasts, newToast];
        if (updatedToasts.length > maxToasts) {
          return updatedToasts.slice(updatedToasts.length - maxToasts);
        }
        return updatedToasts;
      });

      return newToast.id;
    },
    [maxToasts]
  );

  const removeToast = useCallback((id: string) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ toast, removeToast }}>
      {children}
      <ToastContainer toasts={toasts} removeToast={removeToast} />
    </ToastContext.Provider>
  );
}

export default ToastProvider;


--- src/components/ui/Toast/useToast.ts ---
import { useContext } from "react";
import { ToastContext } from "./ToastContext";
import { ToastType } from "./Toast";

interface ToastOptions {
  title?: string;
  message: string;
  type?: ToastType;
  duration?: number;
}

export function useToast() {
  const context = useContext(ToastContext);

  if (context === undefined) {
    throw new Error("useToast must be used within a ToastProvider");
  }

  const { toast: showToast, removeToast } = context;

  const toast = Object.assign((options: ToastOptions) => showToast(options), {
    success: (message: string, title?: string, duration?: number) =>
      showToast({ message, title, type: "success", duration }),
    error: (message: string, title?: string, duration?: number) =>
      showToast({ message, title, type: "error", duration }),
    dismiss: (id: string) => removeToast(id),
  });

  return { toast };
}


--- src/hooks/useDragAndDrop.ts ---
import React, { useMemo, useRef, useState } from "react";
import { UseMutateFunction } from "@tanstack/react-query";

export function useDragAndDrop<T>(mutate: UseMutateFunction<any, Error, T, unknown>) {
  const [draggedItemId, setDraggedItemId] = useState<number | null>(null);
  const dragStartIndex = useRef<number | null>(null);
  const dragEndIndex = useRef<number | null>(null);

  const handleDragStart = (id: number, currentOrder: number) => {
    setDraggedItemId(id);
    dragStartIndex.current = currentOrder;
  };

  const handleDragEnter = (order: number) => (dragEndIndex.current = order);

  const handleDragEnd = (userId: number) => {
    if (draggedItemId && dragStartIndex.current !== null && dragEndIndex.current !== null) {
      if (dragStartIndex.current !== dragEndIndex.current) {
        const mutateData: any = {
          newOrder: dragEndIndex.current,
        };

        if (userId !== -1) {
          mutateData.userId = userId;
          mutateData.listId = draggedItemId;
        } else mutateData.favoriteId = draggedItemId;

        mutate(mutateData);
      }
    }

    setDraggedItemId(null);
    dragStartIndex.current = null;
    dragEndIndex.current = null;
  };

  const handleDragOver = (e: React.DragEvent) => e.preventDefault();

  return useMemo(
    () => ({
      draggedItemId,
      handleDragStart,
      handleDragEnter,
      handleDragEnd,
      handleDragOver,
    }),
    [draggedItemId, mutate]
  );
}


--- src/hooks/useIntersectionObserver.ts ---
import { RefObject, useEffect } from "react";

interface UseIntersectionObserverProps {
  target: RefObject<Element | null>;
  onIntersect: () => void;
  enabled?: boolean;
  rootMargin?: string;
  threshold?: number;
}

export function useIntersectionObserver({
  target,
  onIntersect,
  enabled = true,
  rootMargin = "0px",
  threshold = 0.1,
}: UseIntersectionObserverProps) {
  useEffect(() => {
    if (!enabled || !target.current) return;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            onIntersect();
          }
        });
      },
      {
        rootMargin,
        threshold,
      }
    );

    const element = target.current;
    observer.observe(element);

    return () => {
      if (element) observer.unobserve(element);
    };
  }, [target, enabled, onIntersect, rootMargin, threshold]);
}


--- src/hooks/useMounted.ts ---
import { useEffect, useState } from "react";

export function useMounted() {
  const [mounted, setMounted] = useState(false);

  // 마운트 된 후에만 UI 렌더링
  useEffect(() => {
    setMounted(true);
  }, []);

  return { mounted };
}


--- src/hooks/useQueryInput.ts ---
import React, { FormEvent, useEffect, useRef } from "react";
import { useSetUrlQuery } from "@/hooks/useSetUrlQuery";

interface UseQueryInputReturn {
  inputRef: React.RefObject<HTMLInputElement | null>;
  handleSubmit: (e: FormEvent) => void;
}

export function useQueryInput(initialText: string = "", param: string): UseQueryInputReturn {
  const inputRef = useRef<HTMLInputElement>(null);
  const setUrlQuery = useSetUrlQuery();

  useEffect(() => {
    if (inputRef.current && initialText) {
      inputRef.current.value = initialText;
    }
  }, [initialText]);

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    const text = inputRef.current?.value.trim() || "";
    setUrlQuery(param, text);
  };

  return {
    inputRef,
    handleSubmit,
  };
}


--- src/hooks/useQueryParamState.ts ---
import React, { useState } from "react";
import { useSetUrlQuery } from "@/hooks/useSetUrlQuery";

export function useQueryParamState(initialParam: string, key: string) {
  const [choiceParam, setChoiceParams] = useState(initialParam);
  const setUrlQuery = useSetUrlQuery();

  const applyQueryParams = (e: React.MouseEvent<HTMLButtonElement>): void => {
    const value = e.currentTarget.value as string;
    setChoiceParams(value);
    setUrlQuery(key, value);
  };

  return { choiceParam, applyQueryParams };
}


--- src/hooks/useSetUrlQuery.ts ---
import { usePathname, useRouter, useSearchParams } from "next/navigation";

export function useSetUrlQuery() {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const router = useRouter();

  return (key: string, value: string) => {
    const newParams = new URLSearchParams(searchParams.toString());
    newParams.set(key, value);

    router.push(`${pathname}?${newParams.toString()}`);
  };
}


--- src/lib/axios/instance.ts ---
import axios from "axios";
import { signIn, signOut } from "next-auth/react";
import { authApi } from "@/api/auth";
import { getIsomorphicSession } from "@/utils/getIsomorphicSession";

export const axiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  timeout: 5000,
  headers: {
    "Content-Type": "application/json",
    Accept: "application/json",
  },
});

axiosInstance.interceptors.request.use(
  async function (config) {
    try {
      const session = await getIsomorphicSession();

      if (session?.user?.accessToken) {
        config.headers.Authorization = `Bearer ${session.user.accessToken}`;
      }

      return config;
    } catch (error) {
      console.error("Request interceptor error:", error);
      return config;
    }
  },
  function (error) {
    return Promise.reject(error);
  }
);

const MAX_RETRIES = 3;

axiosInstance.interceptors.response.use(
  function (response) {
    return response;
  },
  async function (error) {
    if (typeof window === "undefined") return;

    const originalRequest = error.config;

    if (originalRequest._retry >= MAX_RETRIES) {
      await signOut({ redirect: true, callbackUrl: "/login?toast=refresh_token_expires" });
      return Promise.reject(error);
    }

    if (error.response && error.response.status === 401) {
      originalRequest._retry ??= 0;
      originalRequest._retry++;

      try {
        const session = await getIsomorphicSession();

        if (!session?.user?.refreshToken) {
          await signOut({ redirect: true, callbackUrl: "/login?toast=refresh_token_expires" });
          return Promise.reject(error);
        }

        const refreshToken = session.user.refreshToken;
        const data = await authApi.refresh(refreshToken);
        originalRequest.headers.Authorization = `Bearer ${data.accessToken}`;

        await signIn("Refresh", {
          accessToken: data.accessToken,
          refreshToken: data.refreshToken,
          redirect: false,
        });

        return axiosInstance(originalRequest);
      } catch (refreshError) {
        console.error(`${originalRequest._retry}th Failed:`, refreshError);
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);


--- src/lib/next-auth/nextAuth.ts ---
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { authApi } from "@/api/auth";

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        try {
          if (!credentials?.email || !credentials?.password) return null;

          const response = await authApi.login(credentials);

          const { user, accessToken, refreshToken } = response;

          if (user && accessToken) {
            return {
              accessToken,
              refreshToken,
              id: user.id,
              email: user.email,
              name: user.name,
              profile_image_url: user.profile_image_url,
            };
          }

          return null;
        } catch (error) {
          return null;
        }
      },
    }),
    CredentialsProvider({
      id: "Refresh",
      name: "Refresh",
      credentials: {
        refreshToken: { label: "RefreshToken", type: "refresh_token" },
        accessToken: { label: "AccessToken", type: "access_token" },
      },
      async authorize(credentials) {
        try {
          if (!credentials?.accessToken || !credentials?.refreshToken) return null;

          const { accessToken, refreshToken } = credentials;
          const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/users/me`, {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
              Authorization: `Bearer ${accessToken}`,
            },
          });

          const data = await response.json();

          return {
            accessToken,
            refreshToken,
            id: data.id,
            email: data.email,
            name: data.name,
            profile_image_url: data.profile_image_url,
          };
        } catch (error) {
          return null;
        }
      },
    }),
  ],
  events: {
    async signOut({ token }) {
      if (token?.accessToken) await authApi.logout(token.accessToken);
    },
  },
  callbacks: {
    async jwt({ token, user, session, trigger }) {
      if (user) {
        token.accessToken = user.accessToken;
        token.refreshToken = user.refreshToken;
        token.id = Number(user.id);
        token.name = user.name;
        token.email = user.email;
        token.profile_image_url = user.profile_image_url;
      }

      if (trigger === "update" && session?.user) {
        if (session.user.profile_image_url) {
          token.profile_image_url = session.user.profile_image_url;
        }
      }

      return token;
    },
    async session({ session, token }) {
      if (token) {
        session.user = token;
      }
      return session;
    },
  },
  session: {
    strategy: "jwt",
    maxAge: 7 * 24 * 60 * 60,
  },
  // pages: {
  //   signIn: "/login",
  //   signOut: "/login?toast=true",
  // },
  secret: process.env.NEXTAUTH_SECRET,
};


--- src/lib/next-auth/nextAuth.type.d.ts ---
import { DefaultSession } from "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      accessToken: string;
      refreshToken: string;
      id: number;
      name: string;
      email: string;
      profile_image_url: string | null;
    } & DefaultSession["user"];
  }

  interface User {
    accessToken: string;
    refreshToken: string;
    id: number;
    name: string;
    email: string;
    profile_image_url: string | null;
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    accessToken: string;
    refreshToken: string;
    id: number;
    name: string;
    email: string;
    profile_image_url: string | null;
  }
}


--- src/lib/tanStackQuery/getServerQueryClient.ts ---
import { defaultShouldDehydrateQuery, QueryClient } from "@tanstack/react-query";
import { DEFAULT_QUERY_OPTIONS } from "./queryConfig";

export function getServerQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        ...DEFAULT_QUERY_OPTIONS,
      },
      dehydrate: {
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) || query.state.status === "pending",
      },
    },
  });
}


--- src/lib/tanStackQuery/queryConfig.ts ---
export const DEFAULT_QUERY_OPTIONS = {
  staleTime: 5 * 60 * 1000,
  gcTime: 10 * 60 * 1000,
  refetchOnMount: false,
  refetchOnWindowFocus: false,
};


--- src/lib/zod/auth.ts ---
import { z } from "zod";

const email = z.string().min(1, "이메일을 입력해주세요").email("올바른 이메일 형식이 아닙니다");
const name = z.string().min(1, "이름을 입력해주세요");
const password = z
  .string()
  .min(1, "비밀번호를 입력해주세요")
  .min(8, "비밀번호는 8자 이상이어야 합니다");
const passwordConfirm = z.string().min(1, "비밀번호 확인을 입력해주세요");

export const loginSchema = z.object({
  email,
  password,
});

export const accountSchema = z
  .object({
    email,
    name,
    password,
    passwordConfirm,
  })
  .refine((data) => data.password === data.passwordConfirm, {
    message: "비밀번호가 일치하지 않습니다",
    path: ["passwordConfirm"],
  });

export const validateSchema = z.object({
  password,
});

export const nameSchema = z.object({
  name: name,
});

export const passwordSchema = z.object({
  password,
  passwordConfirm,
});

export type LoginSchema = z.infer<typeof loginSchema>;
export type AccountSchema = z.infer<typeof accountSchema>;
export type ValidateSchema = z.infer<typeof validateSchema>;
export type NameSchema = z.infer<typeof nameSchema>;
export type PasswordSchema = z.infer<typeof passwordSchema>;


--- src/query/auth/mutations/useAccountMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { AccountRequest } from "@/types/auth.type";
import { authApi } from "@/api/auth";
import { useToast } from "@/components/ui/Toast/useToast";
import { useRouter } from "next/navigation";

export function useAccountMutation() {
  const { toast } = useToast();
  const router = useRouter();

  return useMutation({
    mutationFn: (data: AccountRequest) => authApi.account(data),
    onSuccess: () => {
      router.push("/login");
      toast({
        title: "Account Login Success",
        message: "Account Login Successfully Great!",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Account Login Failed",
        message: `${error.message || "Account Login Failed Something went wrong!"}`,
        type: "error",
      });
    },
  });
}


--- src/query/auth/mutations/useLoginMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { LoginRequest } from "@/types/auth.type";
import { signIn } from "next-auth/react";
import { useToast } from "@/components/ui/Toast/useToast";
import { useRouter } from "next/navigation";

export function useLoginMutation() {
  const { toast } = useToast();
  const router = useRouter();

  return useMutation({
    mutationFn: async (data: LoginRequest) => {
      const result = await signIn("credentials", {
        email: data.email,
        password: data.password,
        redirect: false,
      });

      if (result?.error) {
        throw new Error(result.error);
      }
    },
    onSuccess: () => {
      router.push("/");
      toast({
        title: "Login Success",
        message: "Login Successfully Great!",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Login Failed",
        message: `${error.message || "Login Failed So Sad.."}`,
        type: "error",
      });
    },
  });
}


--- src/query/auth/mutations/useLogoutMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { useToast } from "@/components/ui/Toast/useToast";
import { signOut } from "next-auth/react";
import { useRouter } from "next/navigation";

export function useLogoutMutation() {
  const router = useRouter();
  const { toast } = useToast();

  return useMutation({
    mutationFn: () => signOut({ redirect: false }),
    onSuccess: () => {
      router.push("/login");
      toast({
        title: "Logout Success",
        message: "Logout Successfully Great!",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Logout Failed",
        message: `${error.message || "Logout Failed Stay Restored!"}`,
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/mutations/useAddSongToListMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { AddSongToListRequest } from "@/types/favorite-list.type";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListSongsKey } from "@/query/favorite-lists";
import axios, { AxiosError } from "axios";

export function useAddSongToListMutation(listId: number) {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: AddSongToListRequest) => favoriteListsApi.addSongToList(listId, data),
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListSongsKey(listId) });
      toast({
        title: "Song Added To List Successfully",
        message: data.message,
        type: "success",
      });
    },
    onError: (error) => {
      if (axios.isAxiosError(error)) {
        const axiosError = error as AxiosError<{
          message: string;
          error: string;
          statusCode: number;
        }>;
        const axiosErrorMessage = axiosError.response?.data?.message;

        toast({
          title: "Error",
          message: axiosErrorMessage || error.message,
          type: "error",
        });
      } else {
        // 일반 에러인 경우
        toast({
          title: "Error",
          message: error instanceof Error ? error.message : "Failed To Add Song To List",
          type: "error",
        });
      }
    },
  });
}


--- src/query/favorite-lists/mutations/useCreateFavoriteListMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { CreateFavoriteListRequest, FavoriteList } from "@/types/favorite-list.type";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListsKey } from "@/query/favorite-lists";
import { getRandomInteger } from "@/utils/getRandomInteger";

export function useCreateFavoriteListMutation() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: CreateFavoriteListRequest) => favoriteListsApi.createList(data),
    onMutate: (data) => {
      queryClient.cancelQueries({ queryKey: getFavoriteListsKey() });
      const previousLists = queryClient.getQueryData<FavoriteList[]>(getFavoriteListsKey());

      if (previousLists) {
        const newList = {
          id: -1,
          user_id: -getRandomInteger(),
          name: data.name,
          order: previousLists[previousLists.length - 1].order + 1,
          image_url: null,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          deleted_at: null,
        };
        queryClient.setQueryData(getFavoriteListsKey(), [...previousLists, newList]);

        return { previousLists };
      }
    },
    onSuccess: () => {
      toast({
        title: "My List Created Successfully",
        message: "My List Created Successfully",
        type: "success",
      });
    },
    onError: (error, _, context) => {
      if (context?.previousLists)
        queryClient.setQueryData(getFavoriteListsKey(), context.previousLists);

      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Create My List",
        type: "error",
      });
    },
    onSettled: () => queryClient.invalidateQueries({ queryKey: getFavoriteListsKey() }),
  });
}


--- src/query/favorite-lists/mutations/useDeleteFavoriteListMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListsKey } from "@/query/favorite-lists";
import { FavoriteList } from "@/types/favorite-list.type";

export function useDeleteFavoriteListMutation() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (listId: number) => favoriteListsApi.deleteList(listId),
    onMutate: async (listId) => {
      await queryClient.cancelQueries({ queryKey: getFavoriteListsKey() });
      const previousLists = queryClient.getQueryData<FavoriteList[]>(getFavoriteListsKey());

      if (previousLists) {
        queryClient.setQueryData<FavoriteList[]>(
          getFavoriteListsKey(),
          previousLists.filter((list) => list.id !== listId)
        );
      }

      return { previousLists };
    },
    onSuccess: () => {
      toast({
        title: "My List Deleted Successfully",
        message: "My List Deleted Successfully",
        type: "success",
      });
    },
    onError: (error, _, context) => {
      if (context?.previousLists)
        queryClient.setQueryData(getFavoriteListsKey(), context.previousLists);

      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Delete List",
        type: "error",
      });
    },
    onSettled: () => queryClient.invalidateQueries({ queryKey: getFavoriteListsKey() }),
  });
}


--- src/query/favorite-lists/mutations/useRemoveSongFromListMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListSongsKey } from "@/query/favorite-lists";
import { FavoriteListSong } from "@/types/favorite-list.type";

export function useRemoveSongFromListMutation(listId: number) {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (favoriteId: number) => favoriteListsApi.removeSongFromList(favoriteId),
    onMutate: async (favoriteId) => {
      await queryClient.cancelQueries({ queryKey: getFavoriteListSongsKey(listId) });
      const previousSongs = queryClient.getQueryData<FavoriteListSong[]>(
        getFavoriteListSongsKey(listId)
      );

      if (previousSongs) {
        queryClient.setQueryData(
          getFavoriteListSongsKey(listId),
          previousSongs.filter((song) => song.id !== favoriteId)
        );
      }
      return { previousSongs };
    },
    onSuccess: (data) => {
      toast({
        title: "Song Removed From List Successfully",
        message: data.message,
        type: "success",
      });
    },
    onError: (error, _, context) => {
      if (context?.previousSongs)
        queryClient.setQueryData(getFavoriteListSongsKey(listId), context.previousSongs);

      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Remove Song From List",
        type: "error",
      });
    },
    onSettled: () => queryClient.invalidateQueries({ queryKey: getFavoriteListSongsKey(listId) }),
  });
}


--- src/query/favorite-lists/mutations/useReorderFavoriteList.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useToast } from "@/components/ui/Toast/useToast";
import { ReorderListRequest } from "@/types/favorite-list.type";
import { favoriteListsApi } from "@/api/favorite-lists";
import { getFavoriteListsKey } from "@/query/favorite-lists";

export function useReorderFavoriteList() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: ReorderListRequest) => favoriteListsApi.reorderList(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListsKey() });
      toast({
        title: "My List Order Changed Successfully",
        message: "My List Order Changed Successfully",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Change My List Order",
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/mutations/useReorderSongMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { ReorderSongRequest } from "@/types/favorite-list.type";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListSongsKey } from "@/query/favorite-lists";

export function useReorderSongMutation(listId: number) {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: ReorderSongRequest) => favoriteListsApi.reorderSong(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListSongsKey(listId) });
      toast({
        title: "Song Order Changed Successfully",
        message: "Song Order Changed Successfully",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Change Song Order",
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/mutations/useUpdateFavoriteListMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { FavoriteList, UpdateFavoriteListRequest } from "@/types/favorite-list.type";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListKey, getFavoriteListsKey } from "@/query/favorite-lists";
import { upload } from "@/api/upload";

export function useUpdateFavoriteListMutation(listId: number) {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (
      data: UpdateFavoriteListRequest & {
        isOptimistic?: boolean;
        file?: File | null;
      }
    ) => {
      if (!data.isOptimistic || !data.file) {
        return favoriteListsApi.updateList(listId, {
          name: data.name,
          image_url: data.image_url,
        });
      }

      const uploadResult = await upload(data.file);

      return favoriteListsApi.updateList(listId, {
        name: data.name,
        image_url: uploadResult.url,
      });
    },
    onMutate: async (data) => {
      queryClient.cancelQueries({ queryKey: getFavoriteListsKey() });
      const previousLists = queryClient.getQueryData<FavoriteList[]>(getFavoriteListsKey());

      if (previousLists) {
        const optimisticIndex = previousLists.findIndex((list) => list.id === listId);

        if (optimisticIndex !== -1) {
          const updatedLists = [...previousLists];

          updatedLists[optimisticIndex] = {
            ...updatedLists[optimisticIndex],
            name: data.name ?? updatedLists[optimisticIndex].name,
            image_url: data.image_url ?? updatedLists[optimisticIndex].image_url,
          };

          queryClient.setQueryData(getFavoriteListsKey(), updatedLists);
        }
      }

      return { previousLists };
    },
    onSuccess: () => {
      toast({
        title: "My List Updated Successfully",
        message: "My List Updated Successfully",
        type: "success",
      });
    },
    onError: (error, _, context) => {
      if (context?.previousLists) {
        queryClient.setQueryData(getFavoriteListsKey(), context.previousLists);
      }

      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Update My List",
        type: "error",
      });
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListsKey() });
      queryClient.invalidateQueries({ queryKey: getFavoriteListKey(listId) });
    },
  });
}


--- src/query/favorite-lists/options/favoritListSongsOption.ts ---
import { queryOptions } from "@tanstack/react-query";
import { getFavoriteListSongsKey } from "@/query/favorite-lists";
import { favoriteListsApi } from "@/api/favorite-lists";

export const favoriteListSongsOption = (listId: number) =>
  queryOptions({
    queryKey: getFavoriteListSongsKey(listId),
    queryFn: () => favoriteListsApi.getListSongs(listId),
  });


--- src/query/favorite-lists/options/favoriteListsOption.ts ---
import { queryOptions } from "@tanstack/react-query";
import { getFavoriteListsKey } from "@/query/favorite-lists";
import { favoriteListsApi } from "@/api/favorite-lists";

export const favoriteListsOption = queryOptions({
  queryKey: getFavoriteListsKey(),
  queryFn: () => favoriteListsApi.getLists(),
});


--- src/query/favorite-lists/queries/useFavoriteListSongsQuery.ts ---
import { useSuspenseQuery } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { getFavoriteListSongsKey } from "@/query/favorite-lists";

export function useFavoriteListSongsQuery(listId: number) {
  return useSuspenseQuery({
    queryKey: getFavoriteListSongsKey(listId),
    queryFn: () => favoriteListsApi.getListSongs(listId),
  });
}


--- src/query/favorite-lists/queries/useFavoriteListsQuery.ts ---
import { useSuspenseQuery } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { getFavoriteListsKey } from "@/query/favorite-lists";

export function useFavoriteListsQuery() {
  return useSuspenseQuery({
    queryKey: getFavoriteListsKey(),
    queryFn: () => favoriteListsApi.getLists(),
  });
}


--- src/query/favorite-lists/index.ts ---
export * from "./key";

export * from "./queries/useFavoriteListsQuery";
export * from "./queries/useFavoriteListSongsQuery";

export * from "./mutations/useCreateFavoriteListMutation";
export * from "./mutations/useUpdateFavoriteListMutation";
export * from "./mutations/useDeleteFavoriteListMutation";
export * from "./mutations/useReorderFavoriteList";
export * from "./mutations/useAddSongToListMutation";
export * from "./mutations/useRemoveSongFromListMutation";
export * from "./mutations/useReorderSongMutation";


--- src/query/favorite-lists/key.ts ---
export const getFavoriteListsKey = () => ["favorite-lists"];
export const getFavoriteListSongsKey = (listId: number) => ["favorite-list-songs", listId];
export const getFavoriteListKey = (listId: number) => ["favorite-list", listId];


--- src/query/search/options/searchQueryOption.ts ---
import { getSearchQueryKey } from "@/query/search";
import { searchApi } from "@/api/search";
import { queryOptions } from "@tanstack/react-query";
import { SearchPanelParams } from "@/types/search.type";

export const searchQueryOption = (params: SearchPanelParams) =>
  queryOptions({
    queryKey: getSearchQueryKey({
      text: params.text || "",
      searchType: params.searchType || "both",
      sort: params.sort || "popular",
    }),
    queryFn: () =>
      searchApi({
        text: params.text || "",
        searchType: params.searchType || "both",
        sort: params.sort || "popular",
        page: 1,
        limit: 10,
      }),
  });


--- src/query/search/queries/useSearchQuery.ts ---
import { useInfiniteQuery } from "@tanstack/react-query";
import { searchApi } from "@/api/search";
import { getSearchQueryKey } from "@/query/search";
import { SearchPanelParams } from "@/types/search.type";

export type SearchQueryParams = SearchPanelParams & { text: string };

export function useSearchQuery(params: SearchQueryParams) {
  const { text, searchType, sort } = params;
  const limit = 10;

  return useInfiniteQuery({
    queryKey: getSearchQueryKey(params),
    queryFn: ({ pageParam = 1 }) =>
      searchApi({
        text,
        searchType,
        sort,
        page: pageParam,
        limit,
      }),
    initialPageParam: 1,
    getNextPageParam: (lastPage) => {
      const { total, page, limit } = lastPage;
      const loadedItems = page * limit;

      return loadedItems < total ? page + 1 : undefined;
    },
    enabled: text?.length > 0,
  });
}


--- src/query/search/index.ts ---
export * from "./key";

export * from "./queries/useSearchQuery";


--- src/query/search/key.ts ---
export const getSearchQueryKey = (params: {
  text?: string;
  searchType?: "both" | "artist" | "title" | "lyrics";
  sort?: "latest" | "popular";
}) => ["search", params.text, params.searchType, params.sort];


--- src/query/users/mutations/useDeleteAccountMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { signOut } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useToast } from "@/components/ui/Toast/useToast";
import { usersApi } from "@/api/users";

export function useDeleteAccountMutation() {
  const { toast } = useToast();
  const router = useRouter();

  return useMutation({
    mutationFn: async () => {
      await usersApi.deleteAccount();
      return true;
    },
    onSuccess: async () => {
      await signOut({ redirect: false });
      router.push("/login");
      toast({
        title: "Account Deleted",
        message: "Your account has been deleted successfully.",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Delete Failed",
        message: error instanceof Error ? error.message : "Failed to delete account.",
        type: "error",
      });
    },
  });
}


--- src/query/users/mutations/useUpdateImageMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { useToast } from "@/components/ui/Toast/useToast";
import { usersApi } from "@/api/users";
import { upload } from "@/api/upload";
import { useSession } from "next-auth/react";

interface UpdateProfileRequest {
  file?: File | null;
}

export function useUpdateImageMutation() {
  const { toast } = useToast();
  const { update } = useSession();

  return useMutation({
    mutationFn: async (data: UpdateProfileRequest) => {
      if (!data.file) return null;

      const uploadResult = await upload(data.file);

      return usersApi.modify({ profile_image_url: uploadResult.url });
    },
    onSuccess: async (data) => {
      await update({ user: { profile_image_url: data?.profile_image_url } });
      toast({
        title: "Successfully Updated",
        message: "Your profile has been updated",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Update Failed",
        message: error instanceof Error ? error.message : "Failed to update profile",
        type: "error",
      });
    },
  });
}


--- src/query/users/mutations/useUpdateNameMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useToast } from "@/components/ui/Toast/useToast";
import { usersApi } from "@/api/users";
import { NameSchema } from "@/lib/zod/auth";
import { decrypt } from "@/utils/decrypt";

interface UpdateNameParams {
  data: NameSchema;
  email: string | undefined;
}

export function useUpdateNameMutation() {
  const { toast } = useToast();
  const router = useRouter();

  return useMutation({
    mutationFn: async ({ data, email }: UpdateNameParams) => {
      const passwordSessionStr = sessionStorage.getItem("password");
      if (!passwordSessionStr) throw new Error("Session Ded");

      const passwordSession = JSON.parse(passwordSessionStr);
      if (passwordSession.expires < Date.now()) {
        sessionStorage.removeItem("password");
        throw new Error("Session expired");
      }

      const password = decrypt(passwordSession.value || "");

      await usersApi.modify({ name: data.name });

      const signInResult = await signIn("credentials", {
        email,
        password,
        redirect: false,
      });

      if (!signInResult?.ok) {
        throw new Error(signInResult?.error || "재인증에 실패했습니다.");
      }

      sessionStorage.removeItem("password");

      return true;
    },
    onSuccess: () => {
      toast({
        title: "Successfully Updated",
        message: "Change Name",
        type: "success",
      });
      router.push("/profile");
    },
    onError: (error) => {
      if (error instanceof Error) {
        router.push("/profile/verify/name");
      }
      toast({
        title: "Name Update Failed",
        message: error instanceof Error ? error.message : "Failed to update name.",
        type: "error",
      });
    },
  });
}


--- src/query/users/mutations/useUpdatePasswordMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useToast } from "@/components/ui/Toast/useToast";
import { usersApi } from "@/api/users";
import { PasswordSchema } from "@/lib/zod/auth";

interface UpdatePasswordParams {
  data: PasswordSchema;
  email: string | undefined;
}

export function useUpdatePasswordMutation() {
  const { toast } = useToast();
  const router = useRouter();

  return useMutation({
    mutationFn: async ({ data, email }: UpdatePasswordParams) => {
      await usersApi.modify({ password: data.password });

      const result = await signIn("credentials", {
        email,
        password: data.password,
        redirect: false,
      });

      if (!result?.ok) {
        throw new Error(result?.error || "재인증에 실패했습니다.");
      }

      return true;
    },
    onSuccess: () => {
      toast({
        title: "Successfully Updated",
        message: "Change Password",
        type: "success",
      });
      router.push("/profile");
    },
    onError: (error) => {
      toast({
        title: "Password Update Failed",
        message: error instanceof Error ? error.message : "Failed to update password.",
        type: "error",
      });
    },
  });
}


--- src/query/users/mutations/useVerifyPasswordMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { signIn } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useToast } from "@/components/ui/Toast/useToast";
import { encrypt } from "@/utils/encrypt";

interface VerifyPasswordParams {
  email: string | undefined;
  password: string;
  redirectPath: string;
  changeType: string;
}

export function useVerifyPasswordMutation() {
  const { toast } = useToast();
  const router = useRouter();

  return useMutation({
    mutationFn: async ({ email, password, redirectPath, changeType }: VerifyPasswordParams) => {
      const result = await signIn("credentials", {
        email,
        password,
        redirect: false,
      });

      if (!result?.ok) {
        throw new Error(result?.error || "Failed to VerifyPassword");
      }

      if (changeType === "name") {
        const encryptedData = {
          value: encrypt(password),
          expires: Date.now() + 600000,
        };

        sessionStorage.setItem("password", JSON.stringify(encryptedData));
      }

      return true;
    },
    onSuccess: (_, variables) => {
      router.push(variables.redirectPath);
    },
    onError: (error) => {
      toast({
        title: "이거 뜨면 zod 태업하는거임",
        message: error instanceof Error ? error.message : "Failed to VerifyPassword",
        type: "error",
      });
    },
  });
}


--- src/query/users/index.ts ---
export * from "./mutations/useVerifyPasswordMutation";
export * from "./mutations/useUpdatePasswordMutation";
export * from "./mutations/useUpdateNameMutation";
export * from "./mutations/useUpdatePasswordMutation";
export * from "./mutations/useUpdateImageMutation";


--- src/types/auth.type.ts ---
interface User {
  id: number;
  name: string;
  email: string;
  profile_image_url: string | null;
}

export interface AccountRequest {
  name: string;
  email: string;
  password: string;
}

export type AccountResponse = string;

export type LoginRequest = Omit<AccountRequest, "name">;

export interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  user: User;
}

export type LogoutResponse = string;

export type RefreshRequest = string;

export interface RefreshResponse {
  accessToken: string;
  refreshToken: string;
}


--- src/types/favorite-list.type.ts ---
import { StaticImageData } from "next/image";

export interface FavoriteList {
  id: number;
  user_id: number;
  name: string;
  order: number;
  image_url: StaticImageData | string | null;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface FavoriteListSong {
  id: number;
  list_id: number;
  song_id: number;
  order: number;
  title_ko: string;
  title_ja?: string;
  title_en?: string;
  artist_ko?: string;
  artist_ja?: string;
  artist_en?: string;
  thumbnail_url: StaticImageData | null;
  tj_number?: string;
  kumyoung_number?: string;
  created_at: string;
  updated_at: string;
}

export interface CreateFavoriteListRequest {
  name: string;
}

export interface UpdateFavoriteListRequest {
  name?: string;
  image_url?: string | StaticImageData | null;
}

export interface AddSongToListRequest {
  songId: number;
}

export interface ReorderListRequest {
  userId: number;
  listId: number;
  newOrder: number;
}

export interface ReorderSongRequest {
  favoriteId: number;
  newOrder: number;
}

export type GetFavoriteListsResponse = FavoriteList[];

export type GetFavoriteListSongsResponse = FavoriteListSong[];

export type CreateFavoriteListResponse = FavoriteList;

export type UpdateFavoriteListResponse = FavoriteList;

export interface DeleteFavoriteListResponse {
  message: string;
}

export interface AddSongToListResponse {
  favorite_id: number;
  message: string;
}

export interface RemoveSongFromListResponse {
  message: string;
}

export interface ReorderListResponse {
  message: string;
}

export interface ReorderSongResponse {
  message: string;
}


--- src/types/search.type.ts ---
import { StaticImageData } from "next/image";

export type SearchType = "both" | "artist" | "title" | "lyrics";
export type Sort = "latest" | "popular";

export interface SearchRequest {
  text?: string;
  searchType?: SearchType;
  sort?: Sort;
  limit?: number;
  page?: number;
}

export type SearchPanelParams = Omit<SearchRequest, "limit" | "page">;

export interface SearchItems {
  id: number;
  song_id: number;
  title_ko: string;
  title_ja?: string;
  title_en?: string;
  artist_id: number;
  release_date?: string;
  thumbnail_url: StaticImageData | null;
  popularity_score: number;
  created_at: string;
  updated_at: string;
  artist_ko?: string;
  artist_ja?: string;
  artist_en?: string;
  romanized_ko?: string;
  tj_number?: string;
  kumyoung_number?: string;
}

export interface SearchResponse {
  items: SearchItems[];
  total: number;
  page: number;
  limit: number;
}


--- src/types/users.type.ts ---
import { StaticImageData } from "next/image";

export interface MeResponse {
  id: number;
  name: string;
  email: string;
  profile_image_url: string;
  created_at: string;
  updated_at: string;
}

export type AllResponse = MeResponse[];

export interface MeModifyRequest {
  name?: string;
  password?: string;
  profile_image_url?: StaticImageData | string | null;
}

export interface MeModifyResponse {
  id: number;
  name: string;
  email: string;
  profile_image_url: StaticImageData | string | null;
  created_at: string;
  updated_at: string;
}


--- src/utils/decrypt.ts ---
export const decrypt = (text: string) => {
  return atob(text);
};


--- src/utils/encrypt.ts ---
export const encrypt = (text: string) => {
  return btoa(text);
};


--- src/utils/getIsomorphicSession.ts ---
import { getSession } from "next-auth/react";
import { getServerSession, Session } from "next-auth";
import { authOptions } from "@/lib/next-auth/nextAuth";

export const getIsomorphicSession = async (): Promise<Session | null> => {
  return typeof window === "undefined" ? await getServerSession(authOptions) : await getSession();
};


--- src/utils/getRandomInteger.ts ---
export const getRandomInteger = (max = 99999999999, min = 0) =>
  Math.floor(Math.random() * (max - min) + min);


--- src/utils/getTimeAgo.ts ---
export const getTimeAgo = (dateString: string): string => {
  const date = new Date(dateString.replace("Z", ""));
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);
  
  if (diffInSeconds < 60) {
    return "just now";
  }

  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) {
    return `${diffInMinutes} ${diffInMinutes === 1 ? "minute" : "minutes"} ago`;
  }

  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) {
    return `${diffInHours} ${diffInHours === 1 ? "hour" : "hours"} ago`;
  }

  const diffInDays = Math.floor(diffInHours / 24);
  if (diffInDays < 7) {
    return `${diffInDays} ${diffInDays === 1 ? "day" : "days"} ago`;
  }

  const diffInWeeks = Math.floor(diffInDays / 7);
  if (diffInWeeks < 4) {
    return `${diffInWeeks} ${diffInWeeks === 1 ? "week" : "weeks"} ago`;
  }

  const diffInMonths = Math.floor(diffInDays / 30);
  if (diffInMonths < 12) {
    return `${diffInMonths} ${diffInMonths === 1 ? "month" : "months"} ago`;
  }

  const diffInYears = Math.floor(diffInDays / 365);
  return `${diffInYears} ${diffInYears === 1 ? "year" : "years"} ago`;
};


--- src/utils/theme.ts ---
"use server";

import { cookies } from "next/headers";

export type Theme = "light" | "dark";

export async function setTheme(theme: Theme) {
  const cookieStore = await cookies();

  cookieStore.set({
    name: "theme",
    value: theme,
    httpOnly: true,
    path: "/",
    maxAge: 60 * 60 * 24 * 365,
  });
}

export async function getTheme(): Promise<Theme> {
  const cookieStore = await cookies();
  const theme = cookieStore.get("theme")?.value as Theme;
  return theme === "dark" ? "dark" : "light";
}


