--- src/api/auth.ts ---
import { axiosInstance } from "@/lib/axios/instance";
import {
  AccountRequest,
  AccountResponse,
  LoginRequest,
  LoginResponse,
  LogoutResponse,
  RefreshRequest,
  RefreshResponse,
} from "@/types/auth.type";

const url = "auth";

export const authApi = {
  account: (data: AccountRequest) => axiosInstance.post<AccountResponse>(`${url}/signup`, data),
  login: (data: LoginRequest) => axiosInstance.post<LoginResponse>(`${url}/login`, data),
  logout: () => axiosInstance.post<LogoutResponse>(`${url}/logout`),
  refresh: (refreshToken: RefreshRequest) =>
    axiosInstance.post<RefreshResponse>(`${url}/refresh`, { refreshToken }),
};


--- src/api/users.ts ---
import { axiosInstance } from "@/lib/axios/instance";

const url = "users";

export const usersApi = {
  all: () => axiosInstance.get(`${url}`),
};


--- src/app/(auth)/login/page.tsx ---
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { signIn } from "next-auth/react";
import { loginSchema, LoginSchema } from "@/lib/zod/auth";

export default function LoginPage() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginSchema>({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = async (data: LoginSchema) => {
    try {
      await signIn("credentials", {
        email: data.email,
        password: data.password,
        redirect: false,
      });
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50">
      <div className="w-full max-w-md rounded-lg bg-white p-8 shadow-md">
        <h2 className="mb-6 text-center text-3xl font-bold text-gray-900">로그인</h2>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
          <div>
            <label htmlFor="email" className="block text-sm font-medium text-gray-700">
              이메일
            </label>
            <input
              {...register("email")}
              type="email"
              className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="your@email.com"
            />
            {errors.email && <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>}
          </div>

          <div>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700">
              비밀번호
            </label>
            <input
              {...register("password")}
              type="password"
              className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="********"
            />
            {errors.password && (
              <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
            )}
          </div>
          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full rounded-md bg-blue-600 px-4 py-2 text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:bg-gray-400"
          >
            {isSubmitting ? "로그인 중..." : "로그인"}
          </button>
        </form>
      </div>
    </div>
  );
}


--- src/app/_providers/SessionProvider.tsx ---
"use client";

import React from "react";
import { SessionProvider as Provider } from "next-auth/react";

interface SessionProviderProps {
  children: React.ReactNode;
  session: any;
}

function SessionProvider({ children, session }: SessionProviderProps) {
  return <Provider session={session}>{children}</Provider>;
}

export default SessionProvider;


--- src/app/api/auth/[...nextauth]/route.ts ---
import NextAuth from "next-auth";
import { authOptions } from "@/lib/next-auth/nextAuth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


--- src/app/layout.tsx ---
import React from "react";
import "./globals.css";
import type { Metadata } from "next";
import { Manrope } from "next/font/google";
import { getServerSession } from "next-auth";
import SessionProvider from "@/app/_providers/sessionProvider";

const manrope = Manrope({
  variable: "--font-manrope",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

export const metadata: Metadata = {
  title: "App",
  description: "Generated by create next app",
};

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const session = await getServerSession();

  return (
    <html lang="ko">
      <SessionProvider session={session}>
        <body className={`${manrope.variable} antialiased`}>{children}</body>
      </SessionProvider>
    </html>
  );
}


--- src/app/page.tsx ---
import Input from "@/components/ui/Input";

async function HomePage() {
  return (
    <div>
      <Input />
    </div>
  );
}

export default HomePage;


--- src/components/ui/Input/Input.tsx ---
function Input() {
  return <div>인풋이에요</div>;
}

export default Input;


--- src/components/ui/Input/index.ts ---
export { default } from "./Input";


--- src/lib/axios/instance.ts ---
import axios from "axios";

const token = "abcd";

export const axiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  timeout: 1000,
  headers: {
    "Content-Type": "application/json",
    Accept: "application/json",
    Authorization: `Bearer ${token}`,
  },
});


--- src/lib/next-auth/nextAuth.ts ---
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { authApi } from "@/api/auth";

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        try {
          if (!credentials?.email || !credentials?.password) return null;

          const response = await authApi.login(credentials);

          const { user, accessToken, refreshToken } = response.data;

          if (user && accessToken) {
            return {
              accessToken,
              refreshToken,
              id: user.id,
              email: user.email,
              name: user.name,
            };
          }

          return null;
        } catch (error) {
          return null;
        }
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.accessToken = user.accessToken;
        token.refreshToken = user.refreshToken;
        token.id = Number(user.id);
        token.name = user.name;
        token.email = user.email;
      }
      return token;
    },
    async session({ session, token }) {
      if (token) {
        session.user = token;
      }
      return session;
    },
  },
  session: {
    strategy: "jwt",
    maxAge: 7 * 24 * 60 * 60,
  },
  secret: process.env.NEXTAUTH_SECRET,
};


--- src/lib/next-auth/nextAuth.type.d.ts ---
import { DefaultSession } from "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      accessToken: string;
      refreshToken: string;
      id: number;
      name: string;
      email: string;
    } & DefaultSession["user"];
  }

  interface User {
    accessToken: string;
    refreshToken: string;
    id: number;
    name: string;
    email: string;
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    accessToken: string;
    refreshToken: string;
    id: number;
    name: string;
    email: string;
  }
}


--- src/lib/zod/auth.ts ---
import { z } from "zod";

const email = z.string().min(1, "이메일을 입력해주세요").email("올바른 이메일 형식이 아닙니다");
const name = z.string().min(1, "이름을 입력해주세요");
const password = z
  .string()
  .min(1, "비밀번호를 입력해주세요")
  .min(8, "비밀번호는 8자 이상이어야 합니다");
const passwordConfirm = z.string().min(1, "비밀번호 확인을 입력해주세요");

export const loginSchema = z.object({
  email,
  password,
});

export const accountSchema = z
  .object({
    email,
    name,
    password,
    passwordConfirm,
  })
  .refine((data) => data.password === data.passwordConfirm, {
    message: "비밀번호가 일치하지 않습니다",
    path: ["passwordConfirm"],
  });

export type LoginSchema = z.infer<typeof loginSchema>;
export type AccountSchema = z.infer<typeof accountSchema>;


--- src/types/auth.type.ts ---
interface User {
  id: number;
  name: string;
  email: string;
}

export interface AccountRequest {
  name: string;
  email: string;
  password: string;
}

export type AccountResponse = string;

export type LoginRequest = Omit<AccountRequest, "name">;

export interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  user: User;
}

export type LogoutResponse = string;

export type RefreshRequest = string;

export interface RefreshResponse {
  accessToken: string;
  refreshToken: string;
}


--- src/types/users.type.ts ---


