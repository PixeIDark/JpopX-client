--- src/api/auth.ts ---
import { axiosInstance } from "@/lib/axios/instance";
import {
  AccountRequest,
  AccountResponse,
  LoginRequest,
  LoginResponse,
  RefreshRequest,
  RefreshResponse,
} from "@/types/auth.type";

const url = "auth";

export const authApi = {
  account: (data: AccountRequest) => axiosInstance.post<AccountResponse>(`${url}/signup`, data),
  login: (data: LoginRequest) => axiosInstance.post<LoginResponse>(`${url}/login`, data),
  logout: async (accessToken: string) => {
    try {
      await fetch(`${process.env.NEXT_PUBLIC_API_URL}/auth/logout`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${accessToken}`,
        },
      });
    } catch (error) {
      console.error("Server Logout Failed:", error);
    }
  },
  refresh: async (refreshToken: RefreshRequest): Promise<RefreshResponse> => {
    const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/${url}/refresh`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      body: JSON.stringify({ refreshToken }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }

    return response.json();
  },
};


--- src/api/favorite-lists.ts ---
import { axiosInstance } from "@/lib/axios/instance";
import {
  AddSongToListRequest,
  AddSongToListResponse,
  CreateFavoriteListRequest,
  CreateFavoriteListResponse,
  DeleteFavoriteListResponse,
  GetFavoriteListSongsResponse,
  GetFavoriteListsResponse,
  RemoveSongFromListResponse,
  ReorderListRequest,
  ReorderListResponse,
  ReorderSongRequest,
  ReorderSongResponse,
  UpdateFavoriteListRequest,
  UpdateFavoriteListResponse,
} from "@/types/favorite-list.type";

const url = "favorites";

export const favoriteListsApi = {
  getLists: () => axiosInstance.get<GetFavoriteListsResponse>(`${url}/lists`),

  getListSongs: (listId: number) =>
    axiosInstance.get<GetFavoriteListSongsResponse>(`${url}/lists/${listId}/songs`),

  createList: (data: CreateFavoriteListRequest) =>
    axiosInstance.post<CreateFavoriteListResponse>(`${url}/lists`, data),

  updateList: (listId: number, data: UpdateFavoriteListRequest) =>
    axiosInstance.put<UpdateFavoriteListResponse>(`${url}/lists/${listId}`, data),

  deleteList: (listId: number) =>
    axiosInstance.delete<DeleteFavoriteListResponse>(`${url}/lists/${listId}`),

  reorderList: (data: ReorderListRequest) =>
    axiosInstance.put<ReorderListResponse>(`${url}/lists/reorder`, data),

  addSongToList: (listId: number, data: AddSongToListRequest) =>
    axiosInstance.post<AddSongToListResponse>(`${url}/lists/${listId}/songs`, data),

  removeSongFromList: (favoriteId: number) =>
    axiosInstance.delete<RemoveSongFromListResponse>(`${url}/songs/${favoriteId}`),

  reorderSong: (data: ReorderSongRequest) =>
    axiosInstance.put<ReorderSongResponse>(`${url}/songs/reorder`, data),
};


--- src/api/search.ts ---
import { axiosInstance } from "@/lib/axios/instance";
import { SearchRequest, SearchResponse } from "@/types/search.type";

const url = "search";

export const searchApi = (params: SearchRequest) =>
  axiosInstance.get<SearchResponse>(url, {
    params: {
      text: params.text || "",
      searchType: params.searchType || "both",
      sort: params.sort || "popular",
      limit: params.limit || 20,
      page: params.page || 1,
    },
  });


--- src/api/users.ts ---
import { axiosInstance } from "@/lib/axios/instance";

const url = "users";

export const usersApi = {
  all: () => axiosInstance.get<AllResponse>(`${url}`),
  me: () => axiosInstance.get<MeResponse>(`${url}/me`),
};


--- src/app/(auth)/account/_components/AccountForm/AccountForm.tsx ---
"use client";

import { useForm } from "react-hook-form";
import { accountSchema, AccountSchema } from "@/lib/zod/auth";
import { zodResolver } from "@hookform/resolvers/zod";
import TextField from "@/components/common/Field/TextField";
import PasswordField from "@/components/common/Field/PasswordField";
import Button from "@/components/ui/Button";
import { useAccountMutation } from "@/query/auth/mutations/useAccountMutation";

function AccountForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<AccountSchema>({
    resolver: zodResolver(accountSchema),
  });
  const { mutate: accountMutate } = useAccountMutation();

  const onSubmit = (data: AccountSchema) => accountMutate(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="mt-3 flex flex-col gap-6">
      <TextField
        id="name"
        name="name"
        type="text"
        error={errors.name}
        placeholder="Your name"
        register={register}
      />
      <TextField
        id="email"
        name="email"
        type="email"
        error={errors.email}
        placeholder="Email Address"
        register={register}
      />
      <PasswordField
        id="password"
        name="password"
        error={errors.password}
        placeholder="Password"
        register={register}
      />
      <PasswordField
        id="passwordConfirm"
        name="passwordConfirm"
        error={errors.passwordConfirm}
        placeholder="Confirm Password"
        register={register}
      />
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Loading" : "Account"}
      </Button>
    </form>
  );
}

export default AccountForm;


--- src/app/(auth)/account/_components/AccountForm/index.ts ---
export { default } from "./AccountForm";


--- src/app/(auth)/account/page.tsx ---
import AccountForm from "@/app/(auth)/account/_components/AccountForm";

function AccountPage() {
  return (
    <div>
      <AccountForm />
    </div>
  );
}

export default AccountPage;


--- src/app/(auth)/login/_components/LoginForm/LoginForm.tsx ---
"use client";

import { useForm } from "react-hook-form";
import { loginSchema, LoginSchema } from "@/lib/zod/auth";
import { zodResolver } from "@hookform/resolvers/zod";
import TextField from "@/components/common/Field/TextField";
import PasswordField from "@/components/common/Field/PasswordField";
import Button from "@/components/ui/Button";
import Link from "next/link";
import { useLoginMutation } from "@/query/auth/mutations/useLoginMutation";

function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginSchema>({
    resolver: zodResolver(loginSchema),
  });
  const { mutate: loginMutate } = useLoginMutation();

  const onSubmit = (data: LoginSchema) =>
    loginMutate({
      email: data.email,
      password: data.password,
    });

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="mt-3 flex flex-col gap-6">
      <TextField
        id="email"
        name="email"
        type="email"
        error={errors.email}
        placeholder="Email Address"
        register={register}
      />
      <PasswordField
        id="password"
        name="password"
        error={errors.password}
        placeholder="Password"
        register={register}
      />
      <p className="-mt-2 text-text-p">Forgot password?</p>
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Loading" : "Log in"}
      </Button>
      <Button type="submit" variant="link" asChild>
        <Link href="/account">New User Sign Up</Link>
      </Button>
    </form>
  );
}

export default LoginForm;


--- src/app/(auth)/login/_components/LoginForm/index.ts ---
export { default } from "./LoginForm";


--- src/app/(auth)/login/page.tsx ---
import LoginForm from "@/app/(auth)/login/_components/LoginForm";

export default async function LoginPage() {
  return (
    <div>
      <LoginForm />
    </div>
  );
}


--- src/app/(protected)/add-list/page.tsx ---
function AddListPage() {
  return <div>에드온</div>;
}

export default AddListPage;


--- src/app/(public)/search/_components/SearchPanel/SearchFilter/SearchFilter.tsx ---
import Button from "@/components/ui/Button";
import React from "react";
import { SearchType } from "@/types/search.type";
import { useQueryParamState } from "@/hooks/useQueryParamState";

interface SearchFilterProps {
  initialSearchType: SearchType;
}

const SEARCH_TYPES = ["both", "title", "artist"] as const;

function SearchFilter({ initialSearchType }: SearchFilterProps) {
  const { choiceParam, applyQueryParams } = useQueryParamState(initialSearchType, "search");

  return (
    <div className="flex gap-3">
      {SEARCH_TYPES.map((type, idx) => (
        <Button
          key={idx}
          variant={choiceParam === type ? "outline" : "ghost"}
          value={type}
          onClick={applyQueryParams}
          className="h-11 max-w-[70px] text-sm"
        >
          {type}
        </Button>
      ))}
    </div>
  );
}

export default SearchFilter;


--- src/app/(public)/search/_components/SearchPanel/SearchFilter/index.ts ---
export { default } from "./SearchFilter";


--- src/app/(public)/search/_components/SearchPanel/SearchInput/SearchInput.tsx ---
"use client";

import Input from "@/components/ui/Input";
import { useQueryInput } from "@/hooks/useQueryInput";

interface SearchInputProps {
  initialText: string;
}

function SearchInput({ initialText }: SearchInputProps) {
  const { handleSubmit, inputRef } = useQueryInput(initialText, "text");

  return (
    <form onSubmit={handleSubmit} className="w-full">
      <Input
        placeholder="Please Enter Something"
        ref={inputRef}
        type="text"
        defaultValue={initialText}
      />
    </form>
  );
}

export default SearchInput;


--- src/app/(public)/search/_components/SearchPanel/SearchInput/index.ts ---
export { default } from "./SearchInput";


--- src/app/(public)/search/_components/SearchPanel/SearchSort/SearchSort.tsx ---
"use client";

import Button from "@/components/ui/Button";
import { Sort } from "@/types/search.type";
import React from "react";
import { useQueryParamState } from "@/hooks/useQueryParamState";

interface SearchSortProps {
  initialSort: Sort;
}

const SORT_TYPES = ["popular", "latest"] as const;

function SearchSort({ initialSort }: SearchSortProps) {
  const { choiceParam, applyQueryParams } = useQueryParamState(initialSort, "search");

  return (
    <div className="flex rounded-xl bg-button-ghost p-1">
      {SORT_TYPES.map((sort, idx) => (
        <Button
          key={idx}
          variant={choiceParam === sort ? "link" : "ghost"}
          value={sort}
          onClick={applyQueryParams}
          className="h-8"
        >
          {sort}
        </Button>
      ))}
    </div>
  );
}

export default SearchSort;


--- src/app/(public)/search/_components/SearchPanel/SearchSort/index.ts ---


--- src/app/(public)/search/_components/SearchPanel/SearchPanel.tsx ---
"use client";

import SearchInput from "@/app/(public)/search/_components/SearchPanel/SearchInput";
import SearchFilter from "@/app/(public)/search/_components/SearchPanel/SearchFilter";
import { SearchPanelParams } from "@/types/search.type";
import SearchSort from "@/app/(public)/search/_components/SearchPanel/SearchSort/SearchSort";

interface SearchPanelProps {
  params: SearchPanelParams;
}

function SearchPanel({ params }: SearchPanelProps) {
  const { text = "", searchType = "both", sort = "popular" } = params;

  return (
    <div className="mt-3 flex flex-col gap-3">
      <SearchInput initialText={text} />
      <SearchFilter initialSearchType={searchType} />
      <SearchSort initialSort={sort} />
    </div>
  );
}

export default SearchPanel;


--- src/app/(public)/search/_components/SearchPanel/index.ts ---
export { default } from "./SearchPanel";


--- src/app/(public)/search/_components/SearchResult/SearchList/SearchList.tsx ---
import { SearchItems } from "@/types/search.type";
import SongCard from "@/components/common/SongCard";

interface SearchListProps {
  songs: SearchItems[];
}

function SearchList({ songs }: SearchListProps) {
  return (
    <li className="flex flex-col gap-6">
      {songs.map((song) => (
        <SongCard key={song.id} song={song} />
      ))}
    </li>
  );
}

export default SearchList;


--- src/app/(public)/search/_components/SearchResult/SearchList/index.ts ---
export { default } from "./SearchList";


--- src/app/(public)/search/_components/SearchResult/SearchLoading/SearchLoading.tsx ---
import LoadingSpinner from "@/components/common/LoadingSpinner";

interface SearchResultProps {
  isLoading: boolean;
}

function SearchLoading({ isLoading }: SearchResultProps) {
  return (
    <div className="fixed inset-0 flex items-center justify-center">
      <LoadingSpinner isLoading={isLoading} size={40} />
    </div>
  );
}

export default SearchLoading;


--- src/app/(public)/search/_components/SearchResult/SearchLoading/index.ts ---
export { default } from "./SearchLoading";


--- src/app/(public)/search/_components/SearchResult/_hooks/useSearch.ts ---
import { useCallback, useRef } from "react";
import { useIntersectionObserver } from "@/hooks/useIntersectionObserver";
import { SearchQueryParams, useSearchQuery } from "@/query/search";

export function useSearch(params: SearchQueryParams) {
  const loadMoreRef = useRef<HTMLDivElement>(null);

  const { data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, isError, error } =
    useSearchQuery(params);

  const handleIntersect = useCallback(() => {
    if (hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [fetchNextPage, hasNextPage, isFetchingNextPage]);

  useIntersectionObserver({
    target: loadMoreRef,
    onIntersect: handleIntersect,
    enabled: hasNextPage,
    rootMargin: "20%",
  });

  const searchTotal = data?.pages[0].data.total || 0;
  const songs = data?.pages.flatMap((page) => page.data.items) || [];

  return {
    searchTotal,
    songs,
    isLoading,
    isError,
    error,
    isFetchingNextPage,
    hasNextPage,
    loadMoreRef,
  };
}


--- src/app/(public)/search/_components/SearchResult/SearchResult.tsx ---
"use client";

import { SearchPanelParams } from "@/types/search.type";
import { useSearch } from "@/app/(public)/search/_components/SearchResult/_hooks/useSearch";
import SearchLoading from "@/app/(public)/search/_components/SearchResult/SearchLoading";
import NotFound from "@/components/common/NotFound/NotFound";
import LoadingSpinner from "@/components/common/LoadingSpinner";
import SearchList from "@/app/(public)/search/_components/SearchResult/SearchList";

interface SearchResultProps {
  params: SearchPanelParams;
}

const DISPLAY_COUNT = 2;

function SearchResult({ params }: SearchResultProps) {
  const { loadMoreRef, isLoading, songs, isFetchingNextPage, searchTotal } = useSearch({
    ...params,
    text: params.text || "",
  });

  if (isLoading) return <SearchLoading isLoading={isLoading} />;
  if (!songs.length) return <NotFound text="Don't have any songs!" />;

  const displayLimit = Math.max(0, songs.length - DISPLAY_COUNT);
  const displayedSongs = songs.slice(0, displayLimit);
  const overflowSongs = songs.slice(displayLimit);

  return (
    <div className="mt-2">
      <p className="mb-2 text-sm font-normal text-text-p">{searchTotal} results</p>
      {displayedSongs.length > 0 && <SearchList songs={displayedSongs} />}
      <div ref={loadMoreRef} className="h-0 w-full py-3" />
      {overflowSongs.length > 0 && <SearchList songs={overflowSongs} />}
      {isFetchingNextPage && <LoadingSpinner isLoading={isFetchingNextPage} />}
    </div>
  );
}

export default SearchResult;


--- src/app/(public)/search/_components/SearchResult/index.ts ---
export { default } from "./SearchResult";


--- src/app/(public)/search/page.tsx ---
"use server";

import SearchPanel from "@/app/(public)/search/_components/SearchPanel";
import SearchResult from "@/app/(public)/search/_components/SearchResult";
import { SearchPanelParams } from "@/types/search.type";

async function SearchPage({ searchParams }: { searchParams: Promise<SearchPanelParams> }) {
  const params = await searchParams;

  return (
    <div>
      <SearchPanel params={params} />
      <SearchResult params={params} />
    </div>
  );
}

export default SearchPage;


--- src/app/(public)/page.tsx ---
"use client";

import Button from "@/components/ui/Button";
import Link from "next/link";
import { useToast } from "@/components/ui/Toast/useToast";
import FuckAccessToken from "@/app/_components/test/FuckAccessToken";
import GetMe from "@/app/_components/test/GetMe";
import LogoutMe from "@/app/_components/test/LogoutMe";

function HomePage() {
  const { toast } = useToast();

  const handleButtonClick = () => {
    toast({
      title: "알림",
      message: "작업이 완료되었습니다!",
      type: "error",
    });
  };

  return (
    <div className="flex flex-col gap-2">
      <Button>outline</Button>
      <Button variant="link">link</Button>
      <Button variant="ghost">ghost</Button>
      <Button variant="active" onClick={handleButtonClick}>
        active
      </Button>
      <Button variant="error" asChild>
        <Link href="/search">go to page Search</Link>
      </Button>
      <Button variant="link" asChild>
        <Link href="/login">go to page Login</Link>
      </Button>
      <FuckAccessToken />
      <GetMe />
      <LogoutMe />
    </div>
  );
}

export default HomePage;


--- src/app/_components/layout/BottomNav/BottomNavItem/BottomNavItem.tsx ---
"use client";

import React from "react";
import { usePathname } from "next/navigation";
import Link from "next/link";

interface BottomNavItemProps {
  path: string;
  label: string;
  Icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;
  IconFill: React.ComponentType<React.SVGProps<SVGSVGElement>>;
}

function BottomNavItem({ item }: { item: BottomNavItemProps }) {
  const pathname = usePathname();

  const isActive = item.path === pathname;
  return (
    <Link href={item.path} className="flex w-16 flex-col items-center justify-center gap-1">
      {isActive ? (
        <item.IconFill width={24} height={24} className="fill-icon-bg" />
      ) : (
        <item.Icon width={24} height={24} className="fill-icon-stroke" />
      )}
      <p className="text-xs text-text-p">{item.label}</p>
    </Link>
  );
}

export default BottomNavItem;


--- src/app/_components/layout/BottomNav/BottomNavItem/index.ts ---
export { default } from "./BottomNavItem";


--- src/app/_components/layout/BottomNav/BottomNav.tsx ---
"use client";

import Home from "@/assets/icons/home/home.svg";
import HomeFill from "@/assets/icons/home/home_fill.svg";
import Search from "@/assets/icons/search/search.svg";
import SearchFill from "@/assets/icons/search/search_fill.svg";
import BottomNavItem from "@/app/_components/layout/BottomNav/BottomNavItem";
import { useSelectedLayoutSegment } from "next/navigation";

const NAV_ITEMS = [
  {
    path: "/",
    label: "home",
    Icon: Home,
    IconFill: HomeFill,
  },
  {
    path: "/search",
    label: "search",
    Icon: Search,
    IconFill: SearchFill,
  },
] as const;

function BottomNav() {
  const segment = useSelectedLayoutSegment();
  if (segment === "(auth)") return null;

  return (
    <div>
      <div className="pt fixed bottom-0 flex w-full items-center justify-between border-t border-solid-default bg-body-default px-4 pb-3 pt-5">
        {NAV_ITEMS.map((item) => (
          <BottomNavItem key={item.path} item={item} />
        ))}
      </div>
      <div className="h-[77px] w-full" />
    </div>
  );
}

export default BottomNav;


--- src/app/_components/layout/BottomNav/index.ts ---
export { default } from "./BottomNav";


--- src/app/_components/layout/TopNav/ThemeToggle/ThemeToggle.tsx ---
"use client";

import { useTransition } from "react";
import { useRouter } from "next/navigation";
import { MdLightMode, MdOutlineNightlightRound } from "react-icons/md";
import { setTheme } from "@/utils/theme";

interface ThemeToggleProps {
  currentTheme: "light" | "dark";
}

function ThemeToggle({ currentTheme }: ThemeToggleProps) {
  const router = useRouter();
  const [isPending, startTransition] = useTransition();

  const toggleTheme = async () => {
    const newTheme = currentTheme === "light" ? "dark" : "light";

    await setTheme(newTheme);

    startTransition(() => {
      router.refresh();
    });
  };

  return (
    <button
      onClick={toggleTheme}
      disabled={isPending}
      className="relative h-10 max-h-10 w-10 rounded-md p-2 hover:bg-button-ghost"
      aria-label={`Switch to ${currentTheme === "light" ? "dark" : "light"} mode`}
    >
      {currentTheme === "light" ? (
        <MdOutlineNightlightRound size={24} className="text-text-h" />
      ) : (
        <MdLightMode size={24} className="text-text-h" />
      )}
    </button>
  );
}

export default ThemeToggle;


--- src/app/_components/layout/TopNav/ThemeToggle/index.ts ---
export { default } from "./ThemeToggle";


--- src/app/_components/layout/TopNav/TopNav.tsx ---
"use client";

import { ArrowLeft } from "lucide-react";
import { usePathname, useRouter } from "next/navigation";
import Link from "next/link";
import ThemeToggle from "@/app/_components/layout/TopNav/ThemeToggle";

const NAV_TITLE = {
  "/": "Home",
  "/login": "Login",
  "/account": "Account",
  "/search": "Search",
  "/add-list": "Add List",
} as const;

type NavPath = keyof typeof NAV_TITLE;

interface TopNavProps {
  currentTheme: "light" | "dark";
}

function TopNav({ currentTheme }: TopNavProps) {
  const pathname = usePathname();
  const router = useRouter();

  const title = pathname in NAV_TITLE ? NAV_TITLE[pathname as NavPath] : "Unknown Page";

  return (
    <div className="pt sticky top-0 flex items-center justify-between border-b border-solid-default bg-body-default px-4 pb-3 pt-5">
      <button onClick={() => router.back()} className="p-2">
        <ArrowLeft size={24} strokeWidth={1.5} />
      </button>
      <Link href="/">
        <h1 className="text-lg font-semibold text-text-h">{title}</h1>
      </Link>
      <ThemeToggle currentTheme={currentTheme} />
    </div>
  );
}

export default TopNav;


--- src/app/_components/layout/TopNav/index.ts ---
export { default } from "./TopNav";


--- src/app/_components/test/FuckAccessToken.tsx ---
import Button from "@/components/ui/Button";
import { getSession, signIn } from "next-auth/react";

function FuckAccessToken() {
  const a = async () => {
    const session = await getSession();
    console.log(session);
    const result = await signIn("Refresh", {
      refreshToken: session?.user.refreshToken,
      accessToken: "f",
      redirect: false,
    });
  };

  return <Button onClick={a}>Fuck AccessToken!</Button>;
}

export default FuckAccessToken;


--- src/app/_components/test/GetMe.tsx ---
import Button from "@/components/ui/Button";
import { usersApi } from "@/api/users";

function GetMe() {
  const a = async () => {
    const b = await usersApi.me();
    console.log(b);
  };

  return <Button onClick={a}>Get me</Button>;
}

export default GetMe;


--- src/app/_components/test/LogoutMe.tsx ---
import Button from "@/components/ui/Button";
import { getSession, signOut } from "next-auth/react";

function LogoutMe() {
  const a = async () => {
    let session = await getSession();
    console.log(session);
    await signOut({ redirect: false });
    session = await getSession();
    console.log(session);
  };

  return <Button onClick={a}>log out</Button>;
}

export default LogoutMe;


--- src/app/_providers/QueryProvider.tsx ---
"use client";

import { isServer, QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import * as React from "react";
import { ReactQueryStreamedHydration } from "@tanstack/react-query-next-experimental";

const makeQueryClient = () => {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 60 * 1000,
        gcTime: 10 * 60 * 1000,
        refetchOnMount: false,
        refetchOnWindowFocus: false,
      },
    },
  });
};

let browserQueryClient: QueryClient | undefined = undefined;

const getQueryClient = () => {
  if (isServer) {
    return makeQueryClient();
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
};

function QueryProvider({ children }: { children: React.ReactNode }) {
  const queryClient = getQueryClient();

  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryStreamedHydration>{children}</ReactQueryStreamedHydration>
      <ReactQueryDevtools initialIsOpen={false} buttonPosition="bottom-left" />
    </QueryClientProvider>
  );
}

export default QueryProvider;


--- src/app/_providers/ScrollPositionProvider.tsx ---
"use client";

import React, { useCallback, useEffect, useRef } from "react";

export function ScrollPositionProvider({ children }: { children: React.ReactNode }) {
  const mainRef = useRef<HTMLDivElement | null>(null);
  const previousUrlRef = useRef<string>("");

  const loadScroll = useCallback(() => {
    if (!mainRef.current) return;

    const scrollKey = `scroll_${window.location.href}`;
    const scrollValue = sessionStorage.getItem(scrollKey);

    if (scrollValue && Number(scrollValue) > 0) {
      mainRef.current.scrollTop = Number(scrollValue);
    }
  }, []);

  useEffect(() => {
    const mainElement = document.querySelector("main.overflow-y-auto");
    if (mainElement) mainRef.current = mainElement as HTMLDivElement;

    const updateScrollInUrl = () => {
      if (mainRef.current) {
        const scrollValue = Math.round(mainRef.current.scrollTop);
        if (scrollValue > 0) {
          const scrollKey = `scroll_${window.location.href}`;
          sessionStorage.setItem(scrollKey, scrollValue.toString());
        }

        previousUrlRef.current = window.location.href;
      }
      return true;
    };

    const handlePopState = () => {
      if (mainRef.current) {
        const scrollValue = Math.round(mainRef.current.scrollTop);
        if (scrollValue > 0) {
          const scrollKey = `scroll_${previousUrlRef.current}`;
          sessionStorage.setItem(scrollKey, scrollValue.toString());
        }

        previousUrlRef.current = window.location.href;

        setTimeout(loadScroll, 50);
      }
      return true;
    };

    document.addEventListener("click", updateScrollInUrl, { passive: true });
    window.addEventListener("popstate", handlePopState);

    return () => {
      document.removeEventListener("click", updateScrollInUrl);
      window.removeEventListener("popstate", handlePopState);
    };
  }, [loadScroll]);

  return <>{children}</>;
}


--- src/app/_providers/SessionProvider.tsx ---
"use client";

import React from "react";
import { SessionProvider as Provider } from "next-auth/react";

interface SessionProviderProps {
  children: React.ReactNode;
  session: any;
}

function SessionProvider({ children, session }: SessionProviderProps) {
  return <Provider session={session}>{children}</Provider>;
}

export default SessionProvider;


--- src/app/api/auth/[...nextauth]/route.ts ---
import NextAuth from "next-auth";
import { authOptions } from "@/lib/next-auth/nextAuth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };


--- src/app/layout.tsx ---
import React from "react";
import "./globals.css";
import type { Metadata } from "next";
import { Manrope } from "next/font/google";
import { getServerSession } from "next-auth";
import SessionProvider from "@/app/_providers/SessionProvider";
import QueryProvider from "@/app/_providers/QueryProvider";
import TopNav from "@/app/_components/layout/TopNav";
import BottomNav from "@/app/_components/layout/BottomNav";
import { authOptions } from "@/lib/next-auth/nextAuth";
import ToastProvider from "@/components/ui/Toast/ToastContext";
import { ScrollPositionProvider } from "@/app/_providers/ScrollPositionProvider";
import { getTheme } from "@/utils/theme";

const manrope = Manrope({
  variable: "--font-manrope",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

export const metadata: Metadata = {
  title: "App",
  description: "Generated by create next app",
};

async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const theme = await getTheme();
  const session = await getServerSession(authOptions);

  return (
    <html lang="ko" data-theme={theme} suppressHydrationWarning>
      <body className={`${manrope.variable} antialiasing`}>
        <SessionProvider session={session}>
          <QueryProvider>
            <ToastProvider maxToasts={5}>
              <ScrollPositionProvider>
                <div className="flex h-screen flex-col">
                  <TopNav currentTheme={theme} />
                  <main className="overflow-y-auto px-4">{children}</main>
                  <BottomNav />
                </div>
              </ScrollPositionProvider>
            </ToastProvider>
          </QueryProvider>
        </SessionProvider>
      </body>
    </html>
  );
}

export default RootLayout;


--- src/components/common/Field/ErrorMessage/ErrorMessage.tsx ---
import { FieldError } from "react-hook-form";

function ErrorMessage({ error }: { error: FieldError | undefined }) {
  if (!error) return null;

  return <p className="text-button-error mt-1 text-sm">{error.message}</p>;
}

export default ErrorMessage;


--- src/components/common/Field/ErrorMessage/index.ts ---
export { default } from "./ErrorMessage";


--- src/components/common/Field/PasswordField/EyeButton/EyeButton.tsx ---
import React, { MouseEventHandler } from "react";
import { Eye, EyeOff } from "lucide-react";

interface EyeButtonProps {
  showPassword: boolean;
  togglePassword: MouseEventHandler<HTMLButtonElement>;
}

function EyeButton({ showPassword, togglePassword }: EyeButtonProps) {
  return (
    <button
      type="button"
      className="absolute right-4 top-1/2 -translate-y-1/2"
      onClick={togglePassword}
      aria-label={showPassword ? "Hide password" : "Show password"}
    >
      {showPassword ? (
        <EyeOff strokeWidth={1.5} size={24} className="text-icon-stroke" />
      ) : (
        <Eye strokeWidth={1.5} size={24} className="text-icon-stroke" />
      )}
    </button>
  );
}

export default EyeButton;


--- src/components/common/Field/PasswordField/EyeButton/index.ts ---
export { default } from "./EyeButton";


--- src/components/common/Field/PasswordField/hooks/useInvisiblePassword.ts ---
import { useState } from "react";

export function useInvisiblePassword() {
  const [showPassword, setShowPassword] = useState(false);

  const togglePassword = () => setShowPassword(!showPassword);

  return { showPassword, togglePassword };
}


--- src/components/common/Field/PasswordField/PasswordField.tsx ---
"use client";

import Input from "@/components/ui/Input";
import { FieldError, Path, UseFormRegister } from "react-hook-form";
import ErrorMessage from "@/components/common/Field/ErrorMessage";
import { useInvisiblePassword } from "@/components/common/Field/PasswordField/hooks/useInvisiblePassword";
import EyeButton from "@/components/common/Field/PasswordField/EyeButton";

interface PasswordFieldProps<T extends Record<string, any>> {
  id?: string;
  name: Path<T>;
  placeholder?: string;
  register: UseFormRegister<T>;
  error?: FieldError;
  className?: string;
}

function PasswordField<T extends Record<string, any>>({
  id = "password",
  name,
  placeholder = "Password",
  register,
  error,
  className,
}: PasswordFieldProps<T>) {
  const { showPassword, togglePassword } = useInvisiblePassword();

  return (
    <div>
      <div className={`relative ${className || ""}`}>
        <label htmlFor={id} />
        <Input
          id={id}
          type={showPassword ? "text" : "password"}
          placeholder={placeholder}
          {...register(name)}
        />
        <EyeButton showPassword={showPassword} togglePassword={togglePassword} />
      </div>
      <ErrorMessage error={error} />
    </div>
  );
}

export default PasswordField;


--- src/components/common/Field/PasswordField/index.ts ---
export { default } from "./PasswordField";


--- src/components/common/Field/TextField/TextField.tsx ---
"use client";

import { FieldError, Path, UseFormRegister } from "react-hook-form";
import Input from "@/components/ui/Input";
import ErrorMessage from "@/components/common/Field/ErrorMessage";

interface TextFieldProps<T extends Record<string, any>> {
  id: string;
  name: Path<T>;
  type?: string;
  placeholder?: string;
  register: UseFormRegister<T>;
  error?: FieldError;
  className?: string;
}

function TextField<T extends Record<string, any>>({
  id,
  name,
  type = "text",
  placeholder,
  register,
  error,
  className,
}: TextFieldProps<T>) {
  return (
    <div className={className}>
      <label htmlFor={id} />
      <Input id={id} type={type} placeholder={placeholder} {...register(name)} />
      <ErrorMessage error={error} />
    </div>
  );
}

export default TextField;


--- src/components/common/Field/TextField/index.ts ---
export { default } from "./TextField";


--- src/components/common/LoadingSpinner/LoadingSpinner.tsx ---
import { Loader } from "lucide-react";

interface LoadingSpinnerProps {
  isLoading: boolean;
  className?: string;
  size?: number;
}

function LoadingSpinner({ isLoading, className, size = 24 }: LoadingSpinnerProps) {
  if (!isLoading) return null;

  return (
    <div className={`${className} flex w-full items-center justify-center py-4`}>
      <Loader size={size} className="animate-rotate" />
    </div>
  );
}

export default LoadingSpinner;


--- src/components/common/LoadingSpinner/index.ts ---
export { default } from "./LoadingSpinner";


--- src/components/common/NotFound/NotFound.tsx ---
interface NotFoundProps {
  text?: string;
}

function NotFound({ text = "Not Found" }: NotFoundProps) {
  return (
    <div className="mt-32 flex items-center justify-center">
      <h1 className="text-2xl font-semibold text-text-h">{text}</h1>
    </div>
  );
}

export default NotFound;


--- src/components/common/NotFound/index.ts ---


--- src/components/common/SongCard/SongCard.tsx ---
import { SearchItems } from "@/types/search.type";
import Button from "@/components/ui/Button";
import Picture from "@/components/ui/Picture";
import Link from "next/link";

interface SongCardProps {
  song: SearchItems;
}

function SongCard({ song }: SongCardProps) {
  const title = song.title_ko || song.title_ja;
  const artist = song.artist_ko || song.artist_ja;

  return (
    <ul className="flex flex-row gap-1">
      <div className="h-[70px] min-w-[70px]">
        <Picture
          src={song.thumbnail_url}
          alt={`${artist}'s ${title} Image`}
          className="h-full w-full rounded-xl object-fill"
        />
      </div>
      <div className="ml-3 flex w-full flex-col justify-between">
        <h1
          className="overflow-hidden text-ellipsis whitespace-nowrap text-text-h"
          style={{ maxWidth: "calc(152px + (187 - 152) * ((100vw - 365px) / 35))" }}
        >
          {title}
        </h1>
        <p
          className="overflow-hidden text-ellipsis whitespace-nowrap text-sm text-text-p"
          style={{ maxWidth: "calc(152px + (187 - 152) * ((100vw - 365px) / 35))" }}
        >
          {artist}
        </p>
        <div className="flex gap-2 text-sm">
          <p className="w-16 text-text-tj">TJ {song.tj_number}</p>
          <p className="text-text-ky">KY {song.kumyoung_number}</p>
        </div>
      </div>
      <Button variant="ghost" className="h-8 min-w-20 max-w-20 text-sm font-medium" asChild>
        <Link href="/add-list">Add</Link>
      </Button>
    </ul>
  );
}

export default SongCard;


--- src/components/common/SongCard/index.ts ---
export { default } from "./SongCard";


--- src/components/ui/Button/Button.tsx ---
import React from "react";

const styles = {
  outline: "bg-button-outline border border-stroke-default",
  link: "bg-button-link",
  ghost: "bg-button-ghost",
  active: "bg-button-active text-text-white",
  error: "bg-button-error text-text-white",
} as const;

type ButtonVariant = keyof typeof styles;

interface ButtonProps extends React.ComponentProps<"button"> {
  variant?: ButtonVariant;
  asChild?: boolean;
}

function Button({
  children,
  onClick,
  variant = "outline",
  className,
  asChild = false,
  ...props
}: ButtonProps) {
  const buttonStyles = `${className || ""} ${styles[variant]} button-hover flex justify-center items-center bg-button-active text-text-h h-12 w-full rounded-xl text-base font-semibold transition-all duration-200`;

  if (asChild && React.isValidElement(children)) {
    const childProps = children.props as any;
    const childOnClick = childProps.onClick;

    const combinedOnClick =
      onClick || childOnClick
        ? (e: React.MouseEvent<Element, MouseEvent>) => {
            if (onClick) onClick(e as React.MouseEvent<HTMLButtonElement>);
            if (childOnClick) childOnClick(e);
          }
        : undefined;

    return React.cloneElement(children, {
      ...childProps,
      ...props,
      onClick: combinedOnClick,
      className: `${childProps.className || ""} ${buttonStyles}`,
    });
  }

  return (
    <button onClick={onClick} className={buttonStyles} {...props}>
      {children}
    </button>
  );
}

export default Button;


--- src/components/ui/Button/index.ts ---
export { default } from "./Button";


--- src/components/ui/Input/Input.tsx ---
import React from "react";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      className={`${className || ""}bg-input-input flex h-14 w-full items-center justify-center rounded-xl p-4 text-base text-text-h placeholder:text-text-p focus:outline-none focus:ring-1 focus:ring-solid-default`}
      {...props}
    />
  );
}

export default Input;


--- src/components/ui/Input/index.ts ---
export { default } from "./Input";


--- src/components/ui/Picture/Picture.tsx ---
import React from "react";
import { StaticImageData } from "next/image";
import errorImage from "@/assets/images/src_error.png";
import notFoundImage from "@/assets/images/src_notfound.png";

interface PictureProps extends Omit<React.ImgHTMLAttributes<HTMLImageElement>, "src"> {
  src?: StaticImageData | string;
  fallbackSrc?: StaticImageData | string;
  width?: number;
  height?: number;
}

function Picture({
  src = notFoundImage,
  alt,
  fallbackSrc = errorImage,
  width,
  height,
  ...props
}: PictureProps) {
  const handleError = (e: React.SyntheticEvent<HTMLImageElement, Event>) => {
    e.currentTarget.src = typeof fallbackSrc === "string" ? fallbackSrc : fallbackSrc.src;
  };

  const imgSrc = typeof src === "string" ? src : src.src;

  return (
    <img
      src={imgSrc}
      alt={alt}
      onError={handleError}
      loading="lazy"
      width={width}
      height={height}
      {...props}
    />
  );
}

export default Picture;


--- src/components/ui/Picture/index.ts ---
export { default } from "./Picture";


--- src/components/ui/Toast/Toast.tsx ---
"use client";

import React, { useEffect, useState } from "react";
import { X } from "lucide-react";

const TOAST_LIFETIME = 3 * 1000;

const styles = {
  success: "border-l-button-active text-button-active",
  error: "border-l-button-error text-button-error",
} as const;

export type ToastType = "success" | "error";

export interface ToastProps {
  id: string;
  title?: string;
  message: string;
  type?: ToastType;
  duration?: number;
  onClose: (id: string) => void;
}

function Toast({
  id,
  title,
  message,
  type = "success",
  duration = TOAST_LIFETIME,
  onClose,
}: ToastProps) {
  const [isHovered, setIsHovered] = useState(false);

  useEffect(() => {
    if (duration !== Infinity) {
      const timer = setTimeout(() => {
        onClose(id);
      }, duration);

      return () => clearTimeout(timer);
    }
  }, [id, duration, onClose]);

  return (
    <div
      className={`${styles[type]} animate-fadeIn border-1 mb-2 flex min-w-80 max-w-md items-start justify-between rounded-md border-l-4 border-stroke-default bg-body-default p-4 shadow-md`}
      role="alert"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onMouseUp={() => onClose(id)}
    >
      <div>
        {title && <h1 className="font-bold">{title}</h1>}
        <p className="text-sm text-text-p">{message}</p>
      </div>
      {isHovered && (
        <button
          className="absolute right-2 top-2 transition-opacity duration-200 focus:outline-none"
          onClick={(e) => {
            e.stopPropagation(); // 클릭 이벤트가 상위로 전파되는 것을 방지
            onClose(id);
          }}
          aria-label="닫기"
        >
          <X size={18} />
        </button>
      )}
    </div>
  );
}

export default Toast;


--- src/components/ui/Toast/ToastContainer.tsx ---
import Toast from "./Toast";
import { ToastItem } from "./ToastContext";

interface ToastContainerProps {
  toasts: ToastItem[];
  removeToast: (id: string) => void;
}

function ToastContainer({ toasts, removeToast }: ToastContainerProps) {
  return (
    <div className="fixed bottom-4 right-4 z-50 flex flex-col" aria-live="polite">
      {toasts.map((toast) => (
        <Toast
          key={toast.id}
          id={toast.id}
          title={toast.title}
          message={toast.message}
          type={toast.type}
          duration={toast.duration}
          onClose={removeToast}
        />
      ))}
    </div>
  );
}

export default ToastContainer;


--- src/components/ui/Toast/ToastContext.tsx ---
"use client";

import React, { createContext, ReactNode, useCallback, useState } from "react";
import ToastContainer from "./ToastContainer";
import { ToastType } from "./Toast";

export interface ToastItem {
  id: string;
  title?: string;
  message: string;
  type?: ToastType;
  duration?: number;
}

interface ToastContextType {
  toast: (options: Omit<ToastItem, "id">) => void;
  removeToast: (id: string) => void;
}

export const ToastContext = createContext<ToastContextType | undefined>(undefined);

interface ToastProviderProps {
  children: ReactNode;
  maxToasts?: number;
}

function ToastProvider({ children, maxToasts = 5 }: ToastProviderProps) {
  const [toasts, setToasts] = useState<ToastItem[]>([]);

  const toast = useCallback(
    (options: Omit<ToastItem, "id">) => {
      const newToast = {
        id: crypto.randomUUID(),
        ...options,
      };

      setToasts((prevToasts) => {
        const updatedToasts = [...prevToasts, newToast];
        if (updatedToasts.length > maxToasts) {
          return updatedToasts.slice(updatedToasts.length - maxToasts);
        }
        return updatedToasts;
      });

      return newToast.id;
    },
    [maxToasts]
  );

  const removeToast = useCallback((id: string) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ toast, removeToast }}>
      {children}
      <ToastContainer toasts={toasts} removeToast={removeToast} />
    </ToastContext.Provider>
  );
}

export default ToastProvider;


--- src/components/ui/Toast/useToast.ts ---
import { useContext } from "react";
import { ToastContext } from "./ToastContext";
import { ToastType } from "./Toast";

interface ToastOptions {
  title?: string;
  message: string;
  type?: ToastType;
  duration?: number;
}

export function useToast() {
  const context = useContext(ToastContext);

  if (context === undefined) {
    throw new Error("useToast must be used within a ToastProvider");
  }

  const { toast: showToast, removeToast } = context;

  const toast = Object.assign((options: ToastOptions) => showToast(options), {
    success: (message: string, title?: string, duration?: number) =>
      showToast({ message, title, type: "success", duration }),
    error: (message: string, title?: string, duration?: number) =>
      showToast({ message, title, type: "error", duration }),
    dismiss: (id: string) => removeToast(id),
  });

  return { toast };
}


--- src/hooks/useIntersectionObserver.ts ---
import { RefObject, useEffect } from "react";

interface UseIntersectionObserverProps {
  target: RefObject<Element | null>;
  onIntersect: () => void;
  enabled?: boolean;
  rootMargin?: string;
  threshold?: number;
}

export function useIntersectionObserver({
  target,
  onIntersect,
  enabled = true,
  rootMargin = "0px",
  threshold = 0.1,
}: UseIntersectionObserverProps) {
  useEffect(() => {
    if (!enabled || !target.current) return;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            onIntersect();
          }
        });
      },
      {
        rootMargin,
        threshold,
      }
    );

    const element = target.current;
    observer.observe(element);

    return () => {
      if (element) observer.unobserve(element);
    };
  }, [target, enabled, onIntersect, rootMargin, threshold]);
}


--- src/hooks/useMounted.ts ---
import { useEffect, useState } from "react";

export function useMounted() {
  const [mounted, setMounted] = useState(false);

  // 마운트 된 후에만 UI 렌더링
  useEffect(() => {
    setMounted(true);
  }, []);

  return { mounted };
}


--- src/hooks/useQueryInput.ts ---
import React, { FormEvent, useEffect, useRef } from "react";
import { useSetUrlQuery } from "@/hooks/useSetUrlQuery";

interface UseQueryInputReturn {
  inputRef: React.RefObject<HTMLInputElement | null>;
  handleSubmit: (e: FormEvent) => void;
}

export function useQueryInput(initialText: string = "", param: string): UseQueryInputReturn {
  const inputRef = useRef<HTMLInputElement>(null);
  const setUrlQuery = useSetUrlQuery();

  useEffect(() => {
    if (inputRef.current && initialText) {
      inputRef.current.value = initialText;
    }
  }, [initialText]);

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    const text = inputRef.current?.value.trim() || "";
    setUrlQuery(param, text);
  };

  return {
    inputRef,
    handleSubmit,
  };
}


--- src/hooks/useQueryParamState.ts ---
import React, { useState } from "react";
import { useSetUrlQuery } from "@/hooks/useSetUrlQuery";

export function useQueryParamState(initialParam: string, key: string) {
  const [choiceParam, setChoiceParams] = useState(initialParam);
  const setUrlQuery = useSetUrlQuery();

  const applyQueryParams = (e: React.MouseEvent<HTMLButtonElement>): void => {
    const value = e.currentTarget.value as string;
    setChoiceParams(value);
    setUrlQuery(key, value);
  };

  return { choiceParam, applyQueryParams };
}


--- src/hooks/useSetUrlQuery.ts ---
import { usePathname, useRouter, useSearchParams } from "next/navigation";

export function useSetUrlQuery() {
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const router = useRouter();

  return (key: string, value: string) => {
    const newParams = new URLSearchParams(searchParams.toString());
    newParams.set(key, value);

    router.push(`${pathname}?${newParams.toString()}`);
  };
}


--- src/lib/axios/instance.ts ---
import axios from "axios";
import { signIn, signOut } from "next-auth/react";
import { authApi } from "@/api/auth";
import { getIsomorphicSession } from "@/utils/getIsomorphicSession";

export const axiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  timeout: 5000,
  headers: {
    "Content-Type": "application/json",
    Accept: "application/json",
  },
});

axiosInstance.interceptors.request.use(
  async function (config) {
    try {
      const session = await getIsomorphicSession();

      if (session?.user?.accessToken) {
        config.headers.Authorization = `Bearer ${session.user.accessToken}`;
      }

      return config;
    } catch (error) {
      console.error("Request interceptor error:", error);
      return config;
    }
  },
  function (error) {
    return Promise.reject(error);
  }
);

const MAX_RETRIES = 3;

axiosInstance.interceptors.response.use(
  function (response) {
    return response;
  },
  async function (error) {
    const originalRequest = error.config;

    if (originalRequest._retry >= MAX_RETRIES) {
      await signOut({ redirect: true, callbackUrl: "/login" });
      return Promise.reject(error);
    }

    if (error.response && error.response.status === 401) {
      originalRequest._retry ??= 1;
      originalRequest._retry++;

      try {
        const session = await getIsomorphicSession();

        if (!session?.user?.refreshToken) {
          await signOut({ redirect: true, callbackUrl: "/login" });
          return Promise.reject(error);
        }

        const refreshToken = session.user.refreshToken;
        const data = await authApi.refresh(refreshToken);
        originalRequest.headers.Authorization = `Bearer ${data.accessToken}`;

        await signIn("Refresh", {
          accessToken: data.accessToken,
          refreshToken: data.refreshToken,
          redirect: false,
        });

        return axiosInstance(originalRequest);
      } catch (refreshError) {
        console.error(`${originalRequest._retry}th Failed:`, refreshError);
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);


--- src/lib/next-auth/nextAuth.ts ---
import { NextAuthOptions } from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { authApi } from "@/api/auth";

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        try {
          if (!credentials?.email || !credentials?.password) return null;

          const response = await authApi.login(credentials);

          const { user, accessToken, refreshToken } = response.data;

          if (user && accessToken) {
            return {
              accessToken,
              refreshToken,
              id: user.id,
              email: user.email,
              name: user.name,
              profile_image_url: user.profile_image_url,
            };
          }

          return null;
        } catch (error) {
          return null;
        }
      },
    }),
    CredentialsProvider({
      id: "Refresh",
      name: "Refresh",
      credentials: {
        refreshToken: { label: "RefreshToken", type: "refresh_token" },
        accessToken: { label: "AccessToken", type: "access_token" },
      },
      async authorize(credentials) {
        try {
          if (!credentials?.accessToken || !credentials?.refreshToken) return null;

          const { accessToken, refreshToken } = credentials;
          const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/users/me`, {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
              Authorization: `Bearer ${accessToken}`,
            },
          });

          const data = await response.json();

          return {
            accessToken,
            refreshToken,
            id: data.id,
            email: data.email,
            name: data.name,
            profile_image_url: data.profile_image_url,
          };
        } catch (error) {
          return null;
        }
      },
    }),
  ],
  events: {
    async signOut({ token }) {
      if (token?.accessToken) await authApi.logout(token.accessToken);
    },
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.accessToken = user.accessToken;
        token.refreshToken = user.refreshToken;
        token.id = Number(user.id);
        token.name = user.name;
        token.email = user.email;
        token.profile_image_url = user.profile_image_url;
      }
      return token;
    },
    async session({ session, token }) {
      if (token) {
        session.user = token;
      }
      return session;
    },
  },
  session: {
    strategy: "jwt",
    maxAge: 7 * 24 * 60 * 60,
  },
  // pages: {
  //   signIn: "/login",
  //   error: "/login",
  // },
  secret: process.env.NEXTAUTH_SECRET,
};


--- src/lib/next-auth/nextAuth.type.d.ts ---
import { DefaultSession } from "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      accessToken: string;
      refreshToken: string;
      id: number;
      name: string;
      email: string;
      profile_image_url: string | null;
    } & DefaultSession["user"];
  }

  interface User {
    accessToken: string;
    refreshToken: string;
    id: number;
    name: string;
    email: string;
    profile_image_url: string | null;
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    accessToken: string;
    refreshToken: string;
    id: number;
    name: string;
    email: string;
    profile_image_url: string | null;
  }
}


--- src/lib/zod/auth.ts ---
import { z } from "zod";

const email = z.string().min(1, "이메일을 입력해주세요").email("올바른 이메일 형식이 아닙니다");
const name = z.string().min(1, "이름을 입력해주세요");
const password = z
  .string()
  .min(1, "비밀번호를 입력해주세요")
  .min(8, "비밀번호는 8자 이상이어야 합니다");
const passwordConfirm = z.string().min(1, "비밀번호 확인을 입력해주세요");

export const loginSchema = z.object({
  email,
  password,
});

export const accountSchema = z
  .object({
    email,
    name,
    password,
    passwordConfirm,
  })
  .refine((data) => data.password === data.passwordConfirm, {
    message: "비밀번호가 일치하지 않습니다",
    path: ["passwordConfirm"],
  });

export type LoginSchema = z.infer<typeof loginSchema>;
export type AccountSchema = z.infer<typeof accountSchema>;


--- src/query/auth/mutations/useAccountMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { AccountRequest } from "@/types/auth.type";
import { authApi } from "@/api/auth";
import { useToast } from "@/components/ui/Toast/useToast";

export function useAccountMutation() {
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: AccountRequest) => authApi.account(data),
    onSuccess: () => {
      toast({
        title: "Account Login Success",
        message: "Account Login Successfully Great!",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Account Login Failed",
        message: `${error.message || "Account Login Failed Something went wrong!"}`,
        type: "error",
      });
    },
  });
}


--- src/query/auth/mutations/useLoginMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { LoginRequest } from "@/types/auth.type";
import { signIn } from "next-auth/react";
import { useToast } from "@/components/ui/Toast/useToast";

export function useLoginMutation() {
  const { toast } = useToast();

  return useMutation({
    mutationFn: async (data: LoginRequest) => {
      const result = await signIn("credentials", {
        email: data.email,
        password: data.password,
        redirect: true,
        callbackUrl: "/",
      });

      if (result?.error) {
        throw new Error(result.error);
      }
    },
    onSuccess: () => {
      toast({
        title: "Login Success",
        message: "Login Successfully Great!",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Login Failed",
        message: `${error.message || "Login Failed So Sad.."}`,
        type: "error",
      });
    },
  });
}


--- src/query/auth/mutations/useLogoutMutation.ts ---
import { useMutation } from "@tanstack/react-query";
import { useToast } from "@/components/ui/Toast/useToast";
import { signOut } from "next-auth/react";

export function useLogoutMutation() {
  const { toast } = useToast();

  return useMutation({
    mutationFn: () => signOut({ redirect: true, callbackUrl: "/login" }),
    onSuccess: () => {
      toast({
        title: "Logout Success",
        message: "Logout Successfully Great!",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Logout Failed",
        message: `${error.message || "Logout Failed Stay Restored!"}`,
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/mutations/useAddSongToListMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { AddSongToListRequest } from "@/types/favorite-list.type";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListSongsKey } from "@/query/favorite-lists";

export function useAddSongToListMutation(listId: number) {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: AddSongToListRequest) => favoriteListsApi.addSongToList(listId, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListSongsKey(listId) });
      toast({
        title: "Song Added To List Successfully",
        message: "Song Added To List Successfully",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Add Song To List",
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/mutations/useCreateFavoriteListMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { CreateFavoriteListRequest } from "@/types/favorite-list.type";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListsKey } from "@/query/favorite-lists";

export function useCreateFavoriteListMutation() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: CreateFavoriteListRequest) => favoriteListsApi.createList(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListsKey() });
      toast({
        title: "My List Created Successfully",
        message: "My List Created Successfully",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Create My List",
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/mutations/useDeleteFavoriteListMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListsKey } from "@/query/favorite-lists";

export function useDeleteFavoriteListMutation() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (listId: number) => favoriteListsApi.deleteList(listId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListsKey() });
      toast({
        title: "My List Deleted Successfully",
        message: "My List Deleted Successfully",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Delete List",
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/mutations/useRemoveSongFromListMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListSongsKey } from "@/query/favorite-lists";

export function useRemoveSongFromListMutation(listId: number) {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (favoriteId: number) => favoriteListsApi.removeSongFromList(favoriteId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListSongsKey(listId) });
      toast({
        title: "Song Removed From List Successfully",
        message: "Song Removed From List Successfully",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Remove Song From List",
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/mutations/useReorderFavoriteList.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useToast } from "@/components/ui/Toast/useToast";
import { ReorderListRequest } from "@/types/favorite-list.type";
import { favoriteListsApi } from "@/api/favorite-lists";
import { getFavoriteListsKey } from "@/query/favorite-lists";

export function useReorderFavoriteList() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: ReorderListRequest) => favoriteListsApi.reorderList(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListsKey() });
      toast({
        title: "My List Order Changed Successfully",
        message: "My List Order Changed Successfully",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Change My List Order",
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/mutations/useReorderSongMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { ReorderSongRequest } from "@/types/favorite-list.type";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListSongsKey } from "@/query/favorite-lists";

export function useReorderSongMutation(listId: number) {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: ReorderSongRequest) => favoriteListsApi.reorderSong(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListSongsKey(listId) });
      toast({
        title: "Song Order Changed Successfully",
        message: "Song Order Changed Successfully",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Change Song Order",
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/mutations/useUpdateFavoriteListMutation.ts ---
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { UpdateFavoriteListRequest } from "@/types/favorite-list.type";
import { useToast } from "@/components/ui/Toast/useToast";
import { getFavoriteListKey, getFavoriteListsKey } from "@/query/favorite-lists";

export function useUpdateFavoriteListMutation(listId: number) {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: (data: UpdateFavoriteListRequest) => favoriteListsApi.updateList(listId, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: getFavoriteListsKey() });
      queryClient.invalidateQueries({ queryKey: getFavoriteListKey(listId) });

      toast({
        title: "My List Updated Successfully",
        message: "My List Updated Successfully",
        type: "success",
      });
    },
    onError: (error) => {
      toast({
        title: "Error",
        message: error instanceof Error ? error.message : "Failed To Update My List",
        type: "error",
      });
    },
  });
}


--- src/query/favorite-lists/queries/useFavoriteListSongsQuery.ts ---
import { useQuery } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { getFavoriteListsKey } from "../key";

export function useFavoriteListsQuery() {
  return useQuery({
    queryKey: getFavoriteListsKey(),
    queryFn: () => favoriteListsApi.getLists(),
  });
}


--- src/query/favorite-lists/queries/useFavoriteListsQuery.ts ---
import { useQuery } from "@tanstack/react-query";
import { favoriteListsApi } from "@/api/favorite-lists";
import { getFavoriteListSongsKey } from "../key";

export function useFavoriteListSongsQuery(listId: number) {
  return useQuery({
    queryKey: getFavoriteListSongsKey(listId),
    queryFn: () => favoriteListsApi.getListSongs(listId),
    enabled: !!listId,
  });
}


--- src/query/favorite-lists/index.ts ---
export * from "./key";

export * from "./queries/useFavoriteListsQuery";
export * from "./queries/useFavoriteListSongsQuery";

export * from "./mutations/useCreateFavoriteListMutation";
export * from "./mutations/useUpdateFavoriteListMutation";
export * from "./mutations/useDeleteFavoriteListMutation";
export * from "./mutations/useReorderFavoriteList";
export * from "./mutations/useAddSongToListMutation";
export * from "./mutations/useRemoveSongFromListMutation";
export * from "./mutations/useReorderSongMutation";


--- src/query/favorite-lists/key.ts ---
export const getFavoriteListsKey = () => ["favorite-lists"];
export const getFavoriteListSongsKey = (listId: number) => ["favorite-list-songs", listId];
export const getFavoriteListKey = (listId: number) => ["favorite-list", listId];


--- src/query/search/queries/useSearchQuery.ts ---
import { useInfiniteQuery } from "@tanstack/react-query";
import { searchApi } from "@/api/search";
import { getSearchQueryKey } from "@/query/search";
import { SearchPanelParams } from "@/types/search.type";

export type SearchQueryParams = SearchPanelParams & { text: string };

export function useSearchQuery(params: SearchQueryParams) {
  const { text, searchType, sort } = params;
  const limit = 10;

  return useInfiniteQuery({
    queryKey: getSearchQueryKey(params),
    queryFn: ({ pageParam = 1 }) =>
      searchApi({
        text,
        searchType,
        sort,
        page: pageParam,
        limit,
      }),
    initialPageParam: 1,
    getNextPageParam: (lastPage) => {
      const { total, page, limit } = lastPage.data;
      const loadedItems = page * limit;

      return loadedItems < total ? page + 1 : undefined;
    },
    enabled: text?.length > 0,
  });
}


--- src/query/search/index.ts ---
export * from "./key";

export * from "./queries/useSearchQuery";


--- src/query/search/key.ts ---
export const getSearchQueryKey = (params: {
  text?: string;
  searchType?: "both" | "artist" | "title" | "lyrics";
  sort?: "latest" | "popular";
}) => ["search", params.text, params.searchType, params.sort];


--- src/types/auth.type.ts ---
interface User {
  id: number;
  name: string;
  email: string;
  profile_image_url: string | null;
}

export interface AccountRequest {
  name: string;
  email: string;
  password: string;
}

export type AccountResponse = string;

export type LoginRequest = Omit<AccountRequest, "name">;

export interface LoginResponse {
  accessToken: string;
  refreshToken: string;
  user: User;
}

export type LogoutResponse = string;

export type RefreshRequest = string;

export interface RefreshResponse {
  accessToken: string;
  refreshToken: string;
}


--- src/types/favorite-list.type.ts ---
import { StaticImageData } from "next/image";

export interface FavoriteList {
  id: number;
  user_id: number;
  name: string;
  order: number;
  image_url: StaticImageData | null;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface FavoriteListSong {
  id: number;
  list_id: number;
  song_id: number;
  order: number;
  title_ko: string;
  title_ja?: string;
  title_en?: string;
  artist_ko?: string;
  artist_ja?: string;
  artist_en?: string;
  thumbnail_url: StaticImageData | null;
  tj_number?: string;
  kumyoung_number?: string;
  created_at: string;
  updated_at: string;
}

export interface CreateFavoriteListRequest {
  name: string;
}

export interface UpdateFavoriteListRequest {
  name: string;
}

export interface AddSongToListRequest {
  songId: number;
}

export interface ReorderListRequest {
  userId: number;
  listId: number;
  newOrder: number;
}

export interface ReorderSongRequest {
  favoriteId: number;
  newOrder: number;
}

export type GetFavoriteListsResponse = FavoriteList[];

export interface GetFavoriteListSongsResponse {
  items: FavoriteListSong[];
}

export type CreateFavoriteListResponse = FavoriteList;

export type UpdateFavoriteListResponse = FavoriteList;

export interface DeleteFavoriteListResponse {
  message: string;
}

export interface AddSongToListResponse {
  favorite_id: number;
  message: string;
}

export interface RemoveSongFromListResponse {
  message: string;
}

export interface ReorderListResponse {
  message: string;
}

export interface ReorderSongResponse {
  message: string;
}


--- src/types/search.type.ts ---
import { StaticImageData } from "next/image";

export type SearchType = "both" | "artist" | "title" | "lyrics";
export type Sort = "latest" | "popular";

export interface SearchRequest {
  text?: string;
  searchType?: SearchType;
  sort?: Sort;
  limit?: number;
  page?: number;
}

export type SearchPanelParams = Omit<SearchRequest, "limit" | "page">;

export interface SearchItems {
  id: number;
  song_id: number;
  title_ko: string;
  title_ja?: string;
  title_en?: string;
  artist_id: number;
  release_date?: string;
  thumbnail_url: StaticImageData;
  popularity_score: number;
  created_at: string;
  updated_at: string;
  artist_ko?: string;
  artist_ja?: string;
  artist_en?: string;
  romanized_ko?: string;
  tj_number?: string;
  kumyoung_number?: string;
}

export interface SearchResponse {
  items: SearchItems[];
  total: number;
  page: number;
  limit: number;
}


--- src/types/users.type.ts ---
interface MeResponse {
  id: number;
  name: string;
  email: string;
  profile_image_url: string;
  created_at: string;
  updated_at: string;
}

type AllResponse = MeResponse[];


--- src/utils/getIsomorphicSession.ts ---
import { getSession } from "next-auth/react";
import { getServerSession, Session } from "next-auth";
import { authOptions } from "@/lib/next-auth/nextAuth";

export const getIsomorphicSession = async (): Promise<Session | null> => {
  return typeof window === "undefined" ? await getServerSession(authOptions) : await getSession();
};


--- src/utils/theme.ts ---
"use server";

import { cookies } from "next/headers";

export type Theme = "light" | "dark";

export async function setTheme(theme: Theme) {
  const cookieStore = await cookies();

  cookieStore.set({
    name: "theme",
    value: theme,
    httpOnly: true,
    path: "/",
    maxAge: 60 * 60 * 24 * 365, // 1년
  });
}

export async function getTheme(): Promise<Theme> {
  const cookieStore = await cookies();
  const theme = cookieStore.get("theme")?.value as Theme;
  return theme === "dark" ? "dark" : "light";
}


